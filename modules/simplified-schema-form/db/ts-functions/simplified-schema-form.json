{
  "createdAt": 1670529139660,
  "updatedAt": 1670529139660,
  "deletedAt": 0,
  "createdFirstAt": 1670529139660,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/SimplifiedSchemaForm.tsx",
  "commentsInside": [],
  "rawText": " <TValues extends any[]>(props: {\n  /** unique id for this form */\n  id: string;\n\n  /**\n   * Stack of parameterNames of parents if the form was loaded as a child (subset) of another form, the first item being the grandest parent.\n   */\n  parameterNameStack?: string[];\n  /**\n   * sometimes you have multiple schemas that you want to put in a form, for example if you have a function that takes multiple parameters\n   */\n  parameters: RenderableFunctionParameter[];\n  /**\n   * the value is a json with the structure of the simplified schema. with this you can also prefill the form\n   *\n   * every item in the value array represents the value of the respective parameter\n   */\n  values: undefined | TValues;\n  onChange: (values: TValues) => void;\n  /**\n   * model data (can be filtered) that can be referenced in the schema. This is used to fill the form select inputs so a value can be selected.\n   *\n   * Only fields needed: name, id, slug\n   */\n  referencableModelData?: ReferencableModelData;\n  /** show more info for devs */\n  isDebug?: boolean;\n  /**\n   * used for showing assets in the textarea view\n   */\n  projectRelativeStorageFilePath?: string;\n  /**\n   * If you're editing or creating an item, this should be its name. Can be used for naming assets\n   *\n   * Preferably, this must be realtime, based on the state of this very form, so the default-name of assets can change with the form state...\n   */\n  itemNameOrId?: string;\n  /**\n   * Must be provided in case an asset is stored in a db model\n   */\n  modelName?: string;\n}) => {\n  const {\n    modelName,\n    itemNameOrId,\n    id,\n    onChange,\n    parameters,\n    values,\n    referencableModelData,\n    projectRelativeStorageFilePath,\n    parameterNameStack,\n    isDebug,\n  } = props;\n\n  useEffect(() => {\n    if (!Array.isArray(values)) {\n      const allUndefined = parameters.map(() => undefined) as TValues;\n      onChange(allUndefined);\n    }\n  }, []);\n\n  if (!values) return null;\n\n  /** helper function to change a single parameter */\n  const onChangeParameter = (index: number, value: any) => {\n    // only change the parameter we need to change\n    const newValues = values.map((v, i) =>\n      i === index ? value : v\n    ) as TValues;\n    onChange(newValues);\n  };\n\n  const parameterNames = parameters.map((x) => x.name);\n\n  // For every parameter we are going to return elements\n  const elements = parameters\n    .map((parameter, index) => {\n      if (!parameter.simplifiedSchema) return;\n      const uniqueFieldId = `${id}.${parameter.name}`;\n\n      /**\n       * values[index]\n       */\n      const parameterValue = values[index];\n      const defaultInputFields = {\n        uniqueFieldId,\n        fieldName: uniqueFieldId,\n      };\n\n      const assetInputType = getAssetInputType(\n        parameter.name,\n        parameter.simplifiedSchema?.type\n      );\n\n      // console.log({\n      //   parameter,\n      //   assetInputType,\n      //   projectRelativeStorageFilePath,\n      // });\n      if (assetInputType && projectRelativeStorageFilePath) {\n        // Something like: [function-name]-[nested]-[property]-[item-name/id]\n        const defaultAssetName = [\n          ...(parameterNameStack || []),\n          singularize(parameter.name),\n          itemNameOrId,\n        ]\n          .filter(notEmpty)\n          .join(\"-\");\n\n        const assetInputExtra: AssetInputType[\"extra\"] = {\n          modelName,\n          defaultAssetName,\n          size: \"lg\" as \"lg\",\n          theme: \"Outlined\" as \"Outlined\",\n          projectRelativeReferencingFilePath: projectRelativeStorageFilePath,\n          attachTokenToFilename: true,\n          allowMultiple: assetInputType.isMultiple,\n          inputTypes:\n            // NB: many things are omitted here since they're still a work in progress\n            assetInputType.type === \"asset\"\n              ? undefined\n              : assetInputType.type === \"audio\"\n              ? [\"recordAudio\", \"files\"]\n              : assetInputType.type === \"file\"\n              ? [\"files\"]\n              : assetInputType.type === \"image\"\n              ? [\"camera\", \"files\"]\n              : assetInputType.type === \"video\"\n              ? [\"files\", \"recordScreen\", \"recordVideo\"]\n              : undefined,\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <AssetInput\n              value={parameterValue ? makeArray(parameterValue) : []}\n              onChange={(newValue) => {\n                onChangeParameter(index, newValue);\n              }}\n              className=\"w-96\"\n              extra={assetInputExtra}\n              // parameter={parameter}\n              config={{}}\n              fieldName={parameter.name}\n              uniqueFieldId={parameter.name}\n            />\n          </Div>\n        );\n      }\n\n      // First, let's see if the parametername is a reference parameter.\n      const referencedModelDataItem = getReferencedModelDataItem(\n        parameter.name,\n        referencableModelData\n      );\n\n      // console.log({ referencedModelDataItem });\n      if (referencedModelDataItem?.isReferenceParameter) {\n        return (\n          <ReferenceInput\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            referencedModelDataItem={referencedModelDataItem}\n            defaultInputFields={defaultInputFields}\n            isDebug={isDebug}\n          />\n        );\n      }\n\n      if (parameter.isDbModel && isCalculatedParameter(parameter.name)) {\n        //skip!\n        // NB: if you are wondering how to skip model parameters (e.g. todos when there is a todoSlugs, please check `simplifySchema`, as it has this by default.)\n        return;\n      }\n\n      const possibleReferenceParameterNames =\n        getPossibleReferenceParameterNames(parameter.name);\n      const hasReferenceParameter = !!parameterNames.find((name) =>\n        possibleReferenceParameterNames.includes(name)\n      );\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database. NB: this is also done when simplifying a schema. Adding it here too is kind of unneccessary if you can assume the schemas are correct, so we should probably remove it later!\n      if (hasReferenceParameter) return;\n\n      if (parameter.simplifiedSchema.type === \"array\") {\n        return (\n          <ArrayForm\n            modelName={modelName}\n            key={uniqueFieldId}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema.type === \"object\") {\n        return (\n          <ObjectForm\n            modelName={modelName}\n            parameter={parameter}\n            parameterValue={parameterValue}\n            onChangeParameter={(value: any) => onChangeParameter(index, value)}\n            // passing props\n            itemNameOrId={itemNameOrId}\n            parameterNameStack={parameterNameStack}\n            referencableModelData={referencableModelData}\n            isDebug={isDebug}\n            id={uniqueFieldId}\n            key={uniqueFieldId}\n            projectRelativeStorageFilePath={projectRelativeStorageFilePath}\n          />\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"number\") {\n        const value = values[index] as number | null | undefined;\n\n        const onChangeNumber = (newNumber: number | null | undefined) => {\n          const realNewNumber =\n            !parameter.required &&\n            (newNumber === null || newNumber === undefined)\n              ? undefined\n              : newNumber || 0;\n\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index ? realNewNumber : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n            <NumberInput\n              {...defaultInputFields}\n              onChange={onChangeNumber}\n              value={value}\n              extra={{}}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      if (parameter.simplifiedSchema?.type === \"boolean\") {\n        const value = values[index] as boolean | undefined;\n\n        const onChangeBoolean = (newBoolean: boolean) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? // NB: ony return undefined for an empty string that's not required\n                !parameter.required && newBoolean === false\n                ? undefined\n                : newBoolean\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n\n        return (\n          <Div key={uniqueFieldId}>\n            <ToggleInput\n              {...defaultInputFields}\n              onChange={onChangeBoolean}\n              value={value || false}\n              extra={{ label: renderParameterTitle(parameter, isDebug) }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      // NB: only string text left... sometimes it can be markdown though (textArea would be great here)... But we can't see this yet due to indexation\n\n      const value = values[index] as string | undefined;\n\n      if (parameter.simplifiedSchema?.enum) {\n        const onChangeEnum = (newItemValue: string | null) => {\n          const newValues = values.map((x, i) =>\n            // NB: only change the index we are on\n            i === index\n              ? //   NB: ony return undefined for an empty string that's not required\n                !newItemValue\n                ? null\n                : newItemValue\n              : x\n          ) as TValues;\n\n          onChange(newValues);\n        };\n        const enumItems = parameter.simplifiedSchema.enum.map((enumString) => {\n          return {\n            value: String(enumString),\n            label: humanCase(String(enumString)),\n          };\n        });\n\n        const firstEnumValue = parameter.simplifiedSchema?.enum[0];\n        const firstEnumValueString = firstEnumValue\n          ? String(firstEnumValue)\n          : null;\n\n        // NB: we are changing the state here to set the enum to the first value, if it's not specified\n\n        if (value === undefined) {\n          onChangeEnum(firstEnumValueString);\n        }\n        const currentEnumItemValue = value || firstEnumValueString;\n\n        const currentEnumItem = enumItems.find(\n          (x) => x.value === currentEnumItemValue\n        )!;\n\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <SelectInput\n              {...defaultInputFields}\n              onChange={(item) => onChangeEnum(item?.value || null)}\n              value={currentEnumItem}\n              extra={{ options: enumItems, autoSuggest: enumItems.length > 10 }}\n              config={{}}\n            />\n          </Div>\n        );\n      }\n\n      const onChangeText = (newText: string) => {\n        const newValues = values.map((x, i) =>\n          // NB: only change the index we are on\n          i === index\n            ? //   NB: ony return undefined for an empty string that's not required\n              !parameter.required && newText.length === 0\n              ? undefined\n              : newText\n            : x\n        ) as TValues;\n\n        onChange(newValues);\n      };\n\n      const lastWord = lowerCaseArray(parameter.name).pop()!;\n      const isTextArea = markdownTextParameterNames.includes(lastWord);\n\n      if (isTextArea) {\n        return (\n          <Div key={uniqueFieldId}>\n            {renderParameterTitle(parameter, isDebug)}\n\n            <Div className=\"w-full h-[300px]\">\n              <WriterInput\n                className={`${UI.bareInput} h-[300px] bg-white`}\n                value={value || \"\"}\n                onChange={onChangeText}\n                hideButtons\n                initialWriterView=\"edit\"\n                type=\"markdown\"\n                projectRelativeFilePath={projectRelativeStorageFilePath}\n              />\n            </Div>\n          </Div>\n        );\n      }\n\n      const RightTextInput = passwordTextParameterNames.includes(parameter.name)\n        ? PasswordInput\n        : TextInput;\n\n      return (\n        <Div key={uniqueFieldId}>\n          {renderParameterTitle(parameter, isDebug)}\n\n          <RightTextInput\n            {...defaultInputFields}\n            onChange={onChangeText}\n            value={value || \"\"}\n            extra={{}}\n            config={{}}\n          />\n        </Div>\n      );\n    })\n    .filter(notEmpty);\n\n  return <Div>{elements}</Div>;\n}",
  "name": "SimplifiedSchemaForm",
  "slug": "simplified-schema-form",
  "parameters": [],
  "description": "Recursive component that renders a form for a SimplifiedSchema",
  "returnType": {
    "rawType": "JSX.Element | null",
    "typeDefinition": {
      "optional": true,
      "$ref": "#/definitions/JSX.Element"
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 8,
  "size": {
    "characters": 13283,
    "lines": 403,
    "bytes": 13283,
    "bytesPerCharacter": 1,
    "charactersPerLine": 33,
    "linesPerFile": 403,
    "numberOfFiles": 1
  },
  "id": "zkbmonvccnimavlrtyhomenh"
}