{
  "createdAt": 1669384210209,
  "updatedAt": 1669384210209,
  "deletedAt": 0,
  "createdFirstAt": 1669384210209,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/processAsset.ts",
  "commentsInside": [],
  "rawText": " async (\n  /**\n   * The backendAsset that may need processing\n   */\n  backendAsset?: BackendAsset | BackendAsset[]\n): Promise<undefined | BackendAsset> => {\n  const projectRoot = getProjectRoot();\n  if (!projectRoot) return;\n  const realBackendASset = backendAsset ? takeFirst(backendAsset) : undefined;\n\n  if (!realBackendASset) return;\n\n  const {\n    alt,\n    name,\n    relativePath,\n    temporaryDestination,\n    projectRelativeReferencingFilePath,\n    modelName,\n  } = realBackendASset;\n\n  if (!projectRelativeReferencingFilePath) {\n    log(\n      `processAsset: projectRelativeReferencingFilePath wasn't provided, not processing asset`,\n      { type: \"warning\" }\n    );\n    return undefined;\n  }\n\n  const absoluteReferencingFilePath = path.join(\n    projectRoot,\n    projectRelativeReferencingFilePath\n  );\n\n  // console.log(\"processing asset\", { backendAsset });\n  const slugifiedName = slugify(name && name.length > 0 ? name : \"untitled\");\n\n  if (!relativePath && !temporaryDestination) {\n    log(\"processAsset: no relativePath, no temporaryDestination\", {\n      type: \"warning\",\n    });\n    // NB: we must have either a relativePath or a temporaryDestination, otherwise this is an invalid input\n    return undefined;\n  }\n\n  const absoluteTemporaryDestination = temporaryDestination\n    ? path.join(getTemporaryAssetsFolderPath(), temporaryDestination)\n    : undefined;\n\n  // NB: If a `temporaryDestination` is given, if it doesn't exist, we return nothing, this is an invalid input.\n  if (absoluteTemporaryDestination) {\n    if (!fs.existsSync(absoluteTemporaryDestination)) {\n      log(\"processAsset: absoluteTemporaryDestination does not exist\", {\n        type: \"warning\",\n      });\n\n      return undefined;\n    }\n  }\n\n  const oldAssetStoragePath = relativePath\n    ? path.join(path.parse(absoluteReferencingFilePath).dir, relativePath)\n    : undefined;\n\n  // NB: if a relativePath is provided without a temporaryDestination, it means the file should already be there. If it's not there, we return nothing, invalid input.\n  if (oldAssetStoragePath && !temporaryDestination) {\n    if (!fs.existsSync(oldAssetStoragePath)) {\n      log(\n        `processAsset: oldAssetStoragePath does not exist (${oldAssetStoragePath})`,\n        {\n          type: \"warning\",\n        }\n      );\n\n      return undefined;\n    }\n  }\n\n  // Now we can assume the extension of the temporarydestination is correct, because it gets put there from upload\n  const extension = temporaryDestination\n    ? temporaryDestination.split(\".\").pop()\n    : relativePath?.split(\".\").pop();\n\n  if (!extension) {\n    log(\"processAsset: could not create extension\", { type: \"warning\" });\n\n    // NB: extension must exist now.\n    return undefined;\n  }\n\n  /*\n   */\n\n  const storageLocationInfo = getStorageLocationInfo(\n    absoluteReferencingFilePath,\n    modelName\n  );\n\n  const finalAssetStoragePath = path.join(\n    storageLocationInfo.absoluteAssetBaseFolderPath,\n    `${slugifiedName}.${extension}`\n  );\n\n  let finalAvailableStoragePath: string = finalAssetStoragePath;\n\n  if (absoluteTemporaryDestination) {\n    finalAvailableStoragePath = getFirstAvailableFilename(\n      finalAssetStoragePath\n    );\n\n    await renameAndCreate(\n      absoluteTemporaryDestination,\n      finalAvailableStoragePath\n    );\n  } else if (oldAssetStoragePath) {\n    if (oldAssetStoragePath !== finalAssetStoragePath) {\n      finalAvailableStoragePath = getFirstAvailableFilename(\n        finalAssetStoragePath\n      );\n\n      // the name has changed\n      await renameAndCreate(oldAssetStoragePath, finalAvailableStoragePath);\n    }\n  }\n\n  const newRelativePath = getRelativeLinkPath(\n    absoluteReferencingFilePath,\n    finalAvailableStoragePath\n  );\n\n  //({ newRelativePath });\n\n  return { alt, relativePath: newRelativePath };\n}",
  "name": "processAsset",
  "slug": "process-asset",
  "parameters": [
    {
      "name": "backendAsset",
      "schema": {
        "anyOf": [
          {
            "$ref": "#/definitions/BackendAsset"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/definitions/BackendAsset"
            }
          }
        ],
        "description": "The backendAsset that may need processing"
      },
      "simplifiedSchema": {
        "fullComment": "The backendAsset that may need processing",
        "properties": [],
        "type": "object"
      },
      "required": false
    }
  ],
  "description": "Processes an asset by moving the file in the right location, if needed...\n\n- Alt is kept, nothing to do with it\n- Giving a different name will change the new path\n- relativePath is checked if it exists (if temporaryDestination is undefined). It is used to obtain the extension.\n- temporaryDestination must be checked. if it exists, must replace the file on relativePath calculated from name\n\nAfter processing, this function should return a `BackendAsset` without the non-storable parameters\n\nBEWARE: `absoluteReferencingFilePath`, and for db-models also `modelName`, need to be given here! Otherwise this won't work!",
  "returnType": {
    "rawType": "Promise<import(\"/Users/king/King/operations/tools/asset/asset-type/build/BackendAsset\").BackendAsset | undefined>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 5,
  "size": {
    "characters": 4399,
    "lines": 143,
    "bytes": 4399,
    "bytesPerCharacter": 1,
    "charactersPerLine": 31,
    "linesPerFile": 143,
    "numberOfFiles": 1
  },
  "id": "lghlzvlybzjtbfpuqbsevqiz"
}