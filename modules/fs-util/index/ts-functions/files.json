[{"id":"GApqKKfPSXwjnNQe","commentsInside":[],"rawText":" async (fileObject: { [filePath: string]: any }) => {\n  let s = 0;\n  let e = 0;\n  const writePromises = Object.keys(fileObject).map(async (filePath) => {\n    const value = fileObject[filePath];\n    const success = await writeJsonToFile(filePath, value);\n    if (success) s++;\n    if (!success) e++;\n\n    return success;\n  });\n  await Promise.all(writePromises);\n}","name":"writeToFiles","slug":"write-to-files","parameters":[{"name":"fileObject","schema":{"type":"object"},"simplifiedSchema":{"properties":[],"type":"object"},"required":true}],"description":"writes all values in an object to the file that should be specified as key of that value","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":2,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":451,"lines":13,"bytes":451,"bytesPerCharacter":1,"charactersPerfLine":34.69230769230769,"linesPerFile":13,"numberOfFiles":1}},{"id":"QlMMIINQtIwJdJid","commentsInside":[],"rawText":" async (\n  p: PathLike,\n  mode: number\n): Promise<boolean> => {\n  try {\n    await fs.access(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","name":"canAccess","slug":"can-access","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true},{"name":"mode","schema":{"type":"number"},"simplifiedSchema":{"type":"number"},"required":true}],"description":"uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).","returnType":{"rawType":"Promise<boolean>","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":2,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":401,"lines":13,"bytes":401,"bytesPerCharacter":1,"charactersPerfLine":30.846153846153847,"linesPerFile":13,"numberOfFiles":1}},{"id":"kkDwwyVIeUQWTGmQ","commentsInside":[],"rawText":" (p: PathLike, mode: number): boolean => {\n  try {\n    fs.accessSync(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","name":"canAccessSync","slug":"can-access-sync","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true},{"name":"mode","schema":{"type":"number"},"simplifiedSchema":{"type":"number"},"required":true}],"description":"uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).","returnType":{"rawType":"{}","typeDefinition":{"optional":false,"type":"boolean"},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":true,"isEnumLiteral":false,"simplifiedSchema":{"type":"boolean"}},"maxIndentationDepth":2,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":378,"lines":10,"bytes":378,"bytesPerCharacter":1,"charactersPerfLine":37.8,"linesPerFile":10,"numberOfFiles":1}},{"id":"kzKWGGDRhAbaSviH","commentsInside":[],"rawText":" async (p: PathLike) => canAccess(p, fs.constants.F_OK)","name":"canSee","slug":"can-see","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is visible to the calling process","returnType":{"rawType":"unknown","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":0,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":93,"lines":1,"bytes":93,"bytesPerCharacter":1,"charactersPerfLine":93,"linesPerFile":1,"numberOfFiles":1}},{"id":"ruaSNMpwxRXwnGfC","commentsInside":[],"rawText":" async (p: PathLike) => canAccess(p, fs.constants.R_OK)","name":"canRead","slug":"can-read","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is readable to the calling process","returnType":{"rawType":"unknown","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":0,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":94,"lines":1,"bytes":94,"bytesPerCharacter":1,"charactersPerfLine":94,"linesPerFile":1,"numberOfFiles":1}},{"id":"sdvrgZLXCLzsbEgW","commentsInside":[],"rawText":" async (p: PathLike) => canAccess(p, fs.constants.W_OK)","name":"canWrite","slug":"can-write","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is writable to the calling process","returnType":{"rawType":"unknown","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":0,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":94,"lines":1,"bytes":94,"bytesPerCharacter":1,"charactersPerfLine":94,"linesPerFile":1,"numberOfFiles":1}},{"id":"hHpEiKvYQReQdozE","commentsInside":[],"rawText":" async (p: PathLike) =>\n  canAccess(p, fs.constants.X_OK)","name":"canExecute","slug":"can-execute","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is executable to the calling process","returnType":{"rawType":"unknown","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":98,"lines":2,"bytes":98,"bytesPerCharacter":1,"charactersPerfLine":49,"linesPerFile":2,"numberOfFiles":1}},{"id":"gmGNcjXPYdjYxTEt","commentsInside":[],"rawText":" async (p: PathLike) =>\n  canAccessSync(p, fs.constants.F_OK)","name":"canSeeSync","slug":"can-see-sync","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is visible to the calling process","returnType":{"rawType":"unknown","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":99,"lines":2,"bytes":99,"bytesPerCharacter":1,"charactersPerfLine":49.5,"linesPerFile":2,"numberOfFiles":1}},{"id":"wNnecEdIGZBTpBIr","commentsInside":[],"rawText":" (p: PathLike) => canAccessSync(p, fs.constants.R_OK)","name":"canReadSync","slug":"can-read-sync","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is readable to the calling process","returnType":{"rawType":"{}","typeDefinition":{"optional":false,"type":"boolean"},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":true,"isEnumLiteral":false,"simplifiedSchema":{"type":"boolean"}},"maxIndentationDepth":0,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":92,"lines":1,"bytes":92,"bytesPerCharacter":1,"charactersPerfLine":92,"linesPerFile":1,"numberOfFiles":1}},{"id":"IrsPEtayDvtMMEQc","commentsInside":[],"rawText":" (p: PathLike) =>\n  canAccessSync(p, fs.constants.W_OK)","name":"canWriteSync","slug":"can-write-sync","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is writable to the calling process","returnType":{"rawType":"{}","typeDefinition":{"optional":false,"type":"boolean"},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":true,"isEnumLiteral":false,"simplifiedSchema":{"type":"boolean"}},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":94,"lines":2,"bytes":94,"bytesPerCharacter":1,"charactersPerfLine":47,"linesPerFile":2,"numberOfFiles":1}},{"id":"fBewXUgyJTrUIZtE","commentsInside":[],"rawText":" (p: PathLike) =>\n  canAccessSync(p, fs.constants.X_OK)","name":"canExecuteSync","slug":"can-execute-sync","parameters":[{"name":"p","schema":{"$ref":"#/definitions/PathLike"},"simplifiedSchema":{"description":"Valid types for path values in \"fs\".","properties":[],"type":"object"},"required":true}],"description":"File is executable to the calling process","returnType":{"rawType":"{}","typeDefinition":{"optional":false,"type":"boolean"},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":true,"isEnumLiteral":false,"simplifiedSchema":{"type":"boolean"}},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":96,"lines":2,"bytes":96,"bytesPerCharacter":1,"charactersPerfLine":48,"linesPerFile":2,"numberOfFiles":1}},{"id":"BbbLkadclilpWLtr","commentsInside":[],"rawText":" (\n  ...chunksSegments: (string[] | string)[]\n): string[] => {\n  return (\n    chunksSegments\n      .map((x) => makeArray(x))\n      // small check to prevent crashes in case there is an invalid type given (not a string)\n      .map((chunks) => chunks.filter(notEmpty))\n      .reduce((cumSegments, chunks) => {\n        // first chunk is the combination of itself\n        if (cumSegments.length === 0) return chunks;\n        // all next chunks use the accummualted segments and reduce them\n        const nextCumSegments = cumSegments.reduce((all, segment) => {\n          // for every segment add all the chunks to that segment\n          const newChunks = chunks.map((chunk) => path.join(segment, chunk));\n          //add them to all new cumSegments\n          return all.concat(newChunks);\n        }, [] as string[]);\n        return nextCumSegments;\n      }, [] as string[])\n  );\n}","name":"getPathCombinations","slug":"get-path-combinations","parameters":[{"name":"chunksSegments","schema":{"type":"array","items":{"anyOf":[{"type":"array","items":{"type":"string"}},{"type":"string"}]}},"simplifiedSchema":{"items":[{"schema":{"properties":[],"type":"object"},"name":null}],"type":"array"},"required":true}],"description":"gets combinations for paths\n\ninput: [[\"operation1\",\"operation2\"], \"index/value-export\", [\"index.ts\",\"test.ts\",\"cli.ts\"]]\noutput: [\"operation1/index/value-export/index.ts\",\"operation2/index/value-export/index.ts\",\"operation1/index/value-export/test.ts\",\"operation2/index/value-export/test.ts\",\"operation1/index/value-export/cli.ts\",\"operation2/index/value-export/cli.ts\"]","returnType":{"rawType":"string[]","typeDefinition":{"optional":false,"type":"array","items":{"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]}},"typeCoverage":0,"isArray":true,"isEnum":false,"isObject":true,"isPrimitive":false,"isEnumLiteral":false,"simplifiedSchema":{"items":[{"schema":{"type":"string"},"name":null}],"type":"array"}},"maxIndentationDepth":5,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":1246,"lines":25,"bytes":1246,"bytesPerCharacter":1,"charactersPerfLine":49.84,"linesPerFile":25,"numberOfFiles":1}},{"id":"RYcpaNmGBavtssKv","commentsInside":[],"rawText":" async <T>(\n  p: Path,\n  data: T\n): Promise<boolean> => {\n  if (!data) {\n    console.log({ p, data });\n    return false;\n  }\n  const stringifiedData = JSON.stringify(data);\n\n  const folderToBe = getFolder(p);\n  //first, make sure the folder exists\n  await fs.mkdir(folderToBe, { recursive: true });\n\n  //then write it\n  await fs.writeFile(p, stringifiedData, \"utf8\");\n  return true;\n}","name":"writeJsonToFile","slug":"write-json-to-file","parameters":[{"name":"p","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"write json to a file\n\nmakes the dir and file if they don't exist","returnType":{"rawType":"Promise<boolean>","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":2,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":448,"lines":20,"bytes":448,"bytesPerCharacter":1,"charactersPerfLine":22.4,"linesPerFile":20,"numberOfFiles":1}},{"id":"VUeJErQrgAawcnjG","commentsInside":[],"rawText":" (p: string) =>\n  p.charAt(0) === \"/\" ? p.slice(1) : p","name":"removeTrailingSlash","slug":"remove-trailing-slash","parameters":[{"name":"p","schema":{"type":"string"},"simplifiedSchema":{"type":"string"},"required":true}],"description":"","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":54,"lines":2,"bytes":54,"bytesPerCharacter":1,"charactersPerfLine":27,"linesPerFile":2,"numberOfFiles":1}},{"id":"sUpoxogSUJjEbtlR","commentsInside":[],"rawText":" (fileName: Path): string | undefined => {\n  const parts = fileName.split(\".\");\n  //removes extension\n  parts.pop();\n  //returns extension that's left (the sub-extension)\n  const subExtension = parts.pop();\n  return subExtension;\n}","name":"getSubExtension","slug":"get-sub-extension","parameters":[{"name":"fileName","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"","returnType":{"rawType":"string | undefined","typeDefinition":{"optional":true,"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false,"simplifiedSchema":{"type":"string"}},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":231,"lines":8,"bytes":231,"bytesPerCharacter":1,"charactersPerfLine":28.875,"linesPerFile":8,"numberOfFiles":1}},{"id":"tBUwfudtrRaOvHpT","commentsInside":[],"rawText":" (pathString: Path) => {\n  const lastFolder = getFolder(pathString).split(\"/\").pop()!;\n  // console.log({ pathString, lastFolder });\n  return lastFolder;\n}","name":"getLastFolder","slug":"get-last-folder","parameters":[{"name":"pathString","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"removes everything after the last slash to get folder path\n\ninput: /Users/king/Documents/some/folder/xyz\noutput: xyz\n\ninput: /Users/king/Documents/some/folder/xyz.txt\noutput: folder","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":336,"lines":11,"bytes":336,"bytesPerCharacter":1,"charactersPerfLine":30.545454545454547,"linesPerFile":11,"numberOfFiles":1}},{"id":"KRxDoFCSOiHgxfiL","commentsInside":[],"rawText":" (pathString: Path) => {\n  const parsedPath = path.parse(pathString);\n  const hasExtension = parsedPath.ext.length > 0;\n\n  if (hasExtension) {\n    // NB: assume it's a file, let's avoid folders with dots!\n    const pathChunks = pathString.split(\"/\");\n    pathChunks.pop(); //remove the filename\n    return pathChunks.join(\"/\");\n  } else {\n    // NB: it's already a folder!\n    return pathString;\n  }\n}","name":"getFolder","slug":"get-folder","parameters":[{"name":"pathString","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"if the path exists:\n- if the pathString is a folder, that is returned.\n- if the pathstring is not a folder, returns the pathstring without the file suffix\n\nif the path doesn't exist: returns pathString witout last chunk (this would only work for file paths)","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":2,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":658,"lines":18,"bytes":658,"bytesPerCharacter":1,"charactersPerfLine":36.55555555555556,"linesPerFile":18,"numberOfFiles":1}},{"id":"CwJatrdacgSymFOI","commentsInside":[],"rawText":" (pathString: Path) => {\n  return path.basename(pathString);\n}","name":"getFileName","slug":"get-file-name","parameters":[{"name":"pathString","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"removes everything before the last slash to get folder path","returnType":{"rawType":"String","typeDefinition":{"optional":false,"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":true,"isEnumLiteral":false,"simplifiedSchema":{"type":"string"}},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":121,"lines":3,"bytes":121,"bytesPerCharacter":1,"charactersPerfLine":40.333333333333336,"linesPerFile":3,"numberOfFiles":1}},{"id":"cVQoGIDiJcayrMor","commentsInside":[],"rawText":" (fileName: Path) => {\n  const pieces = fileName.split(\".\");\n  pieces.pop();\n  return pieces.join(\".\");\n}","name":"withoutExtension","slug":"without-extension","parameters":[{"name":"fileName","schema":{"$ref":"#/definitions/Path"},"simplifiedSchema":{"description":"unlike PathLike, this is only a string\n\nFor now, we don't have a clear convention whether or not this string should be absolute or anything.","type":"string"},"required":true}],"description":"removes extension from the filename","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":140,"lines":5,"bytes":140,"bytesPerCharacter":1,"charactersPerfLine":28,"linesPerFile":5,"numberOfFiles":1}},{"id":"HdBGbiaKjrcTlzBy","commentsInside":[],"rawText":" (fileNameOrPath: string) => {\n  const pieces = fileNameOrPath.split(\".\");\n  return pieces.pop()!;\n}","name":"getExtension","slug":"get-extension","parameters":[{"name":"fileNameOrPath","schema":{"type":"string"},"simplifiedSchema":{"type":"string"},"required":true}],"description":"returns the extension of the filename or path\n\nNB: not sure, but could be nice to replace this with path.extname(pathString)","returnType":{"rawType":"any","typeCoverage":0,"isArray":false,"isEnum":false,"isObject":false,"isPrimitive":false,"isEnumLiteral":false},"maxIndentationDepth":1,"relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","size":{"characters":224,"lines":6,"bytes":224,"bytesPerCharacter":1,"charactersPerfLine":37.333333333333336,"linesPerFile":6,"numberOfFiles":1}}]