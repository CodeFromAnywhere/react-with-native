[{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"writes all values in an object to the file that should be specified as key of that value","rawStatement":"export const writeToFiles = async (fileObject: { [filePath: string]: any }) => {\n  let s = 0;\n  let e = 0;\n  const writePromises = Object.keys(fileObject).map(async (filePath) => {\n    const value = fileObject[filePath];\n    const success = await writeJsonToFile(filePath, value);\n    if (success) s++;\n    if (!success) e++;\n\n    return success;\n  });\n  await Promise.all(writePromises);\n};","parameters":{},"types":[],"firstLine":8,"lastLine":10},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).","rawStatement":"export const canAccess = async (\n  p: PathLike,\n  mode: number\n): Promise<boolean> => {\n  try {\n    await fs.access(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};","parameters":{},"types":[],"firstLine":25,"lastLine":29},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"uses fs.access to determine if something can be accessed\n\nCheck File access constants for possible values of mode. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g. fs.constants.W_OK | fs.constants.R_OK).","rawStatement":"export const canAccessSync = (p: PathLike, mode: number): boolean => {\n  try {\n    fs.accessSync(p, mode);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};","parameters":{},"types":[],"firstLine":42,"lastLine":46},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is visible to the calling process","rawStatement":"export const canSee = async (p: PathLike) => canAccess(p, fs.constants.F_OK);","parameters":{},"types":[],"firstLine":55,"lastLine":57},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is readable to the calling process","rawStatement":"export const canRead = async (p: PathLike) => canAccess(p, fs.constants.R_OK);","parameters":{},"types":[],"firstLine":59,"lastLine":61},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is writable to the calling process","rawStatement":"export const canWrite = async (p: PathLike) => canAccess(p, fs.constants.W_OK);","parameters":{},"types":[],"firstLine":63,"lastLine":65},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is executable to the calling process","rawStatement":"export const canExecute = async (p: PathLike) =>\n  canAccess(p, fs.constants.X_OK);","parameters":{},"types":[],"firstLine":67,"lastLine":69},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is visible to the calling process","rawStatement":"export const canSeeSync = async (p: PathLike) =>\n  canAccessSync(p, fs.constants.F_OK);","parameters":{},"types":[],"firstLine":73,"lastLine":75},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is readable to the calling process","rawStatement":"export const canReadSync = (p: PathLike) => canAccessSync(p, fs.constants.R_OK);","parameters":{},"types":[],"firstLine":78,"lastLine":80},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is writable to the calling process","rawStatement":"export const canWriteSync = (p: PathLike) =>\n  canAccessSync(p, fs.constants.W_OK);","parameters":{},"types":[],"firstLine":82,"lastLine":84},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"File is executable to the calling process","rawStatement":"export const canExecuteSync = (p: PathLike) =>\n  canAccessSync(p, fs.constants.X_OK);","parameters":{},"types":[],"firstLine":87,"lastLine":89},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"gets combinations for paths\n\ninput: [[\"operation1\",\"operation2\"], \"index/value-export\", [\"index.ts\",\"test.ts\",\"cli.ts\"]]\noutput: [\"operation1/index/value-export/index.ts\",\"operation2/index/value-export/index.ts\",\"operation1/index/value-export/test.ts\",\"operation2/index/value-export/test.ts\",\"operation1/index/value-export/cli.ts\",\"operation2/index/value-export/cli.ts\"]","rawStatement":"export const getPathCombinations = (\n  ...chunksSegments: (string[] | string)[]\n): string[] => {\n  return (\n    chunksSegments\n      .map((x) => makeArray(x))\n      // small check to prevent crashes in case there is an invalid type given (not a string)\n      .map((chunks) => chunks.filter(notEmpty))\n      .reduce((cumSegments, chunks) => {\n        // first chunk is the combination of itself\n        if (cumSegments.length === 0) return chunks;\n        // all next chunks use the accummualted segments and reduce them\n        const nextCumSegments = cumSegments.reduce((all, segment) => {\n          // for every segment add all the chunks to that segment\n          const newChunks = chunks.map((chunk) => path.join(segment, chunk));\n          //add them to all new cumSegments\n          return all.concat(newChunks);\n        }, [] as string[]);\n        return nextCumSegments;\n      }, [] as string[])\n  );\n};","parameters":{},"types":[],"firstLine":93,"lastLine":98},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"write json to a file\n\nmakes the dir and file if they don't exist","rawStatement":"export const writeJsonToFile = async <T>(\n  p: Path,\n  data: T\n): Promise<boolean> => {\n  if (!data) {\n    console.log({ p, data });\n    return false;\n  }\n  const stringifiedData = JSON.stringify(data);\n\n  const folderToBe = getFolder(p);\n  //first, make sure the folder exists\n  await fs.mkdir(folderToBe, { recursive: true });\n\n  //then write it\n  await fs.writeFile(p, stringifiedData, \"utf8\");\n  return true;\n};","parameters":{},"types":[],"firstLine":122,"lastLine":126},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"removes everything after the last slash to get folder path\n\ninput: /Users/king/Documents/some/folder/xyz\noutput: xyz\n\ninput: /Users/king/Documents/some/folder/xyz.txt\noutput: folder","rawStatement":"export const getLastFolder = (pathString: Path) => {\n  const lastFolder = getFolder(pathString).split(\"/\").pop()!;\n  // console.log({ pathString, lastFolder });\n  return lastFolder;\n};","parameters":{},"types":[],"firstLine":158,"lastLine":166},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"if the path exists:\n- if the pathString is a folder, that is returned.\n- if the pathstring is not a folder, returns the pathstring without the file suffix\n\nif the path doesn't exist: returns pathString witout last chunk (this would only work for file paths)","rawStatement":"export const getFolder = (pathString: Path) => {\n  const parsedPath = path.parse(pathString);\n  const hasExtension = parsedPath.ext.length > 0;\n\n  if (hasExtension) {\n    // NB: assume it's a file, let's avoid folders with dots!\n    const pathChunks = pathString.split(\"/\");\n    pathChunks.pop(); //remove the filename\n    return pathChunks.join(\"/\");\n  } else {\n    // NB: it's already a folder!\n    return pathString;\n  }\n};","parameters":{},"types":[],"firstLine":173,"lastLine":179},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"removes everything before the last slash to get folder path","rawStatement":"export const getFileName = (pathString: Path) => {\n  return path.basename(pathString);\n};","parameters":{},"types":[],"firstLine":195,"lastLine":197},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"removes extension from the filename","rawStatement":"export const withoutExtension = (fileName: Path) => {\n  const pieces = fileName.split(\".\");\n  pieces.pop();\n  return pieces.join(\".\");\n};","parameters":{},"types":[],"firstLine":202,"lastLine":205},{"id":"GSptZNnYlXdxgYkB","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-util/src/files.ts","srcFileId":"/files","operationFolderName":"fs-util","relativeFilePathFromSrc":"/files.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-util","operationName":"fs-util","comment":"returns the extension of the filename or path\n\nNB: not sure, but could be nice to replace this with path.extname(pathString)","rawStatement":"export const getExtension = (fileNameOrPath: string) => {\n  const pieces = fileNameOrPath.split(\".\");\n  return pieces.pop()!;\n};","parameters":{},"types":["nb"],"firstLine":212,"lastLine":216}]