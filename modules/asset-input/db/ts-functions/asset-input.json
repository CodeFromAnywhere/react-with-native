{
  "createdAt": 1670526809544,
  "updatedAt": 1670526809544,
  "deletedAt": 0,
  "createdFirstAt": 1670526809544,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/AssetInput.tsx",
  "commentsInside": [],
  "rawText": " (props: {\n  /**\n   * If true, an unique token will be attached as a suffix to the filename of the asset after uploading. This will not be shown to the user in the user-interface, because it will be removed from the input state.\n   *\n   * The token is 32 characters and makes it impossible for a villain to get unauthorised access to the asset without knowing the address, eventhough the asset can be public.\n   *\n   * NB: this is not 100% secure, because the asset is still exposed via a GET address, this is only secure if the user has a private device. The token will still be stored in the browser history!\n   */\n  attachTokenToFilename?: boolean;\n  /**\n   * default asset name if it doesn't come from a file...\n   *\n   * This value may change (e.g. based on form state... The AssetInput ensures that unchanged names update accordingly as well!)\n   */\n  defaultAssetName: string;\n\n  /**\n   * if true, you can select multiple assets\n   */\n  allowMultiple?: boolean;\n\n  /**\n   * specify the input types (defaults to all)\n   */\n  inputTypes?: NewAssetType[];\n\n  value?: BackendAsset[];\n\n  /**\n   * onChange function to set new assets with\n   *\n   * NB: is only called after uploading is complete\n   */\n  onChange: (value: BackendAsset[]) => void;\n\n  projectRelativeReferencingFilePath: string;\n  /**\n   * Must be provided in case the asset is stored in a database\n   */\n  modelName?: string;\n}) => {\n  const {\n    attachTokenToFilename,\n    defaultAssetName,\n    onChange,\n    allowMultiple,\n    value,\n    inputTypes,\n    projectRelativeReferencingFilePath,\n    modelName,\n  } = props;\n\n  /**\n   * generate a random token for this component, once, only if it loads...\n   */\n  const [randomToken] = useState(generateRandomString(32));\n\n  const defaultAssetNameWithToken = ensureToken(\n    defaultAssetName,\n    randomToken,\n    attachTokenToFilename\n  );\n\n  const alert = useAlert();\n\n  const defaultNewType =\n    inputTypes && inputTypes.length === 1 ? inputTypes[0] : null;\n  const [newType, setNewType] = useState<null | NewAssetType>(defaultNewType);\n\n  // NB: `newBlobs` are assets that haven't been confirmed yet. Will not be uploaded yet\n  const [newBlobs, setNewBlobs] = useState<Asset[]>([]);\n  /**\n   * NB: `selectedBlobs` are assets that have been confirmed, but not sent back to `onChange` yet because upload isn't complete yet.\n   *\n   * NB: Ensure to also use `onChange` after asset has been uploaded...\n   */\n  const [selectedBlobs, setSelectedBlobs] = useState<Asset[]>(value || []);\n\n  // NB: we need to ensure the asset names update if the defaultAssetName changes\n  const [lastDefaultAssetName, setLastDefaultAssetName] = useState(\n    defaultAssetNameWithToken\n  );\n\n  useEffect(() => {\n    const newSelectedBlobs = selectedBlobs.map((selectedBlob) => {\n      if (selectedBlob.name === lastDefaultAssetName) {\n        // NB: if the assetname wasn't changed yet, adhere convention\n        return { ...selectedBlob, name: defaultAssetNameWithToken };\n      }\n\n      return selectedBlob;\n    });\n    setSelectedBlobs(newSelectedBlobs);\n    setLastDefaultAssetName(defaultAssetNameWithToken);\n  }, [defaultAssetNameWithToken]);\n\n  /**\n   * Removes asset from selectedBlobs, external value, and at the server\n   */\n  const removeAsset = async (asset: Asset, index: number) => {\n    const newLocalValue = removeIndexFromArray(selectedBlobs, index);\n    setSelectedBlobs(newLocalValue);\n\n    const newStateValue = removeIndexFromArray(value || [], index);\n    onChange(newStateValue);\n\n    if (asset.relativePath) {\n      // if the asset was already in a final location, also try to delete it there...\n\n      const { result } = await api.deleteReferencedAsset(\n        projectRelativeReferencingFilePath,\n        asset.relativePath\n      );\n\n      const isSuccessful = result?.isSuccessful;\n\n      alert?.(\n        isSuccessful ? \"Deleted\" : \"Something went wrong\",\n        result?.message\n      );\n    }\n  };\n\n  /**\n   * Local update!\n   */\n  const updateAssetBlob = (blobPath: string, newAssetBlob: Asset) => {\n    setSelectedBlobs((oldValue) => {\n      const newSelectedBlobs = oldValue.map((assetBlob) =>\n        assetBlob.blobPath === blobPath ? newAssetBlob : assetBlob\n      );\n      return newSelectedBlobs;\n    });\n  };\n\n  /**\n   Sends a blob to the api\n  */\n  const sendBlob = async (\n    asset: Asset,\n    config?: { apiUrl?: string; authToken?: string }\n  ): Promise<RealApiReturnType<\"uploadAssetWithContext\"> | undefined> => {\n    if (!asset.blob || !asset.blobPath) {\n      console.log(\"Please provide a blob and blobPath to send the blob\");\n      return;\n    }\n\n    // Getting the needed information\n    const storageAuthToken: string | undefined = await getItem(\n      AUTH_TOKEN_STORAGE_KEY\n    );\n    const authToken = config?.authToken || storageAuthToken;\n    const realApiUrl = config?.apiUrl || apiUrl;\n    const url = `${realApiUrl}/function/uploadAssetWithContext`;\n\n    // Creating a XMLHTTPRequest for uploading\n    const xhr = new XMLHttpRequest();\n    const xhrResult = await new Promise<{\n      isSuccessful: boolean;\n      response?: UploadAssetResult;\n    }>((resolve, reject) => {\n      xhr.upload.addEventListener(\"abort\", () => {\n        console.log(\"XHR Upload Abort\");\n        reject({ isSuccessful: false });\n      });\n      xhr.upload.addEventListener(\"error\", () => {\n        console.log(\"XHR Upload Error\");\n        reject({ isSuccessful: false });\n      });\n      xhr.upload.addEventListener(\"timeout\", () => {\n        console.log(\"XHR Upload Timeout\");\n        reject({ isSuccessful: false });\n      });\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const uploadProgress = event.loaded / event.total;\n          // console.log(\"upload progress:\", uploadProgress);\n\n          updateAssetBlob(asset.blobPath!, { ...asset, uploadProgress });\n        }\n      });\n      xhr.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const downloadProgress = event.loaded / event.total;\n          // console.log(\"download progress:\", downloadProgress);\n          // TODO: set this to a state\n        }\n      });\n      xhr.addEventListener(\"loadend\", (e) => {\n        const isSuccessful = xhr.readyState === 4 && xhr.status === 200;\n        const response = xhr.response ? JSON.parse(xhr.response) : undefined;\n        resolve({ isSuccessful, response });\n      });\n      xhr.addEventListener(\"timeout\", (ev) => {\n        console.log(\"XHR Timeout\");\n        reject({ isSuccessful: false });\n      });\n      xhr.addEventListener(\"error\", (ev) => {\n        console.log(\"XHR Error\");\n        reject({ isSuccessful: false });\n      });\n      xhr.addEventListener(\"abort\", (ev) => {\n        console.log(\"XHR Aborted\");\n        reject({ isSuccessful: false });\n      });\n      xhr.open(\"POST\", url, true);\n      const formData = new FormData();\n      formData.append(\"file\", asset.blob!);\n      if (authToken) {\n        // NB: we need to adhere the `api` convention!\n        formData.append(\"authToken\", authToken);\n      }\n\n      xhr.send(formData);\n    });\n\n    // NB: now, call onchange\n    // console.log(\"success:\", xhrResult);\n    return xhrResult.response;\n  };\n\n  /**\n   Happens when clicking \"âœ…\"\n   \n   Adds the blob inside of `newBlob` to the blobs. Also sends the blob to the backend\n   */\n  const addBlobs = async () => {\n    if (newBlobs.length === 0) return;\n    setSelectedBlobs([...selectedBlobs, ...newBlobs]);\n    setNewBlobs([]);\n\n    const newStuff = (\n      await Promise.all(\n        newBlobs.map(async (newBlob) => {\n          const sendBlobResult = await sendBlob(newBlob);\n          if (!sendBlobResult) return;\n\n          const newSelectedBlob = {\n            ...newBlob,\n            temporaryDestination: sendBlobResult.result?.temporaryDestination,\n          };\n\n          const newBackendAsset: BackendAsset = makeBackendAsset(\n            newSelectedBlob,\n            projectRelativeReferencingFilePath,\n            modelName\n          );\n\n          return { newSelectedBlob, newBackendAsset };\n        })\n      )\n    ).filter(notEmpty);\n\n    const newBackendAssets = newStuff.map((x) => x.newBackendAsset);\n    const newSelectedBlobs = newStuff.map((x) => x.newSelectedBlob);\n\n    setSelectedBlobs(newSelectedBlobs);\n    onChange(value ? [...value, ...newBackendAssets] : newBackendAssets);\n  };\n\n  const renderChooseType = () => {\n    return (\n      <Div className=\"flex flex-row\">\n        {!inputTypes || inputTypes.includes(\"recordAudio\") ? (\n          <ClickableIcon emoji=\"ðŸ”ˆ\" onClick={() => setNewType(\"recordAudio\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"recordVideo\") ? (\n          <ClickableIcon emoji=\"ðŸŽ¥\" onClick={() => setNewType(\"recordVideo\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"recordScreen\") ? (\n          <ClickableIcon\n            emoji=\"ðŸ’»\"\n            onClick={() => setNewType(\"recordScreen\")}\n          />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"camera\") ? (\n          <ClickableIcon emoji=\"ðŸ“¸\" onClick={() => setNewType(\"camera\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"files\") ? (\n          <ClickableIcon emoji=\"ðŸ“‚\" onClick={() => setNewType(\"files\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"project-media\") ? (\n          <ClickableIcon\n            emoji=\"ðŸ‘‘\"\n            onClick={() => setNewType(\"project-media\")}\n          />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"p2p-media\") ? (\n          <ClickableIcon emoji=\"ðŸ‘¥\" onClick={() => setNewType(\"p2p-media\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"youtube\") ? (\n          <ClickableIcon emoji=\"â¯\" onClick={() => setNewType(\"youtube\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"google-images\") ? (\n          <ClickableIcon\n            emoji=\"ðŸ”Ž\"\n            onClick={() => setNewType(\"google-images\")}\n          />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"giphy\") ? (\n          <ClickableIcon emoji=\"ðŸ¦„\" onClick={() => setNewType(\"giphy\")} />\n        ) : null}\n        {!inputTypes || inputTypes.includes(\"unsplashed\") ? (\n          <ClickableIcon emoji=\"ðŸŒ…\" onClick={() => setNewType(\"unsplashed\")} />\n        ) : null}\n      </Div>\n    );\n  };\n\n  const renderNavigation = () => {\n    return (\n      <Div className=\"flex flex-row justify-between\">\n        {!defaultNewType ? (\n          <ClickableIcon\n            emoji=\"âŒ\"\n            onClick={() => {\n              setNewBlobs([]);\n\n              if (!defaultNewType) {\n                setNewType(null);\n              }\n              // TODO: also safely remove the MediaHandler\n            }}\n          />\n        ) : (\n          <Div />\n        )}\n\n        {newBlobs.length > 0 ? (\n          <ClickableIcon\n            emoji=\"âœ…\"\n            onClick={() => {\n              addBlobs();\n              setNewBlobs([]);\n\n              if (!defaultNewType) {\n                setNewType(null);\n              }\n            }}\n          />\n        ) : (\n          <Div />\n        )}\n      </Div>\n    );\n  };\n\n  const renderAssets = () => {\n    return (\n      <Div>\n        {newType === null ? renderChooseType() : null}\n        {selectedBlobs?.map((asset, index) => (\n          <InteractiveAsset\n            attachTokenToFilename={attachTokenToFilename}\n            projectRelativeReferencingFilePath={\n              projectRelativeReferencingFilePath\n            }\n            key={`asset${index}`}\n            asset={asset}\n            remove={async () => removeAsset(asset, index)}\n            onChange={(newAsset) => {\n              const newSelectedBlobs = selectedBlobs.map((selectedBlob, i) =>\n                i === index ? newAsset : asset\n              );\n              setSelectedBlobs(newSelectedBlobs);\n\n              const newBackendAssets: BackendAsset[] | undefined = value\n                ? value.map((valueItem) => {\n                    const id =\n                      valueItem.relativePath || valueItem.temporaryDestination;\n                    const newAssetId =\n                      newAsset.relativePath || newAsset.temporaryDestination;\n\n                    if (\n                      id !== undefined &&\n                      newAssetId !== undefined &&\n                      id === newAssetId\n                    ) {\n                      return makeBackendAsset(\n                        newAsset,\n                        projectRelativeReferencingFilePath,\n                        modelName\n                      );\n                    }\n\n                    return valueItem;\n                  })\n                : undefined;\n\n              if (newBackendAssets) {\n                onChange(newBackendAssets);\n              }\n            }}\n          />\n        ))}\n      </Div>\n    );\n  };\n\n  const renderSpecificAssetInput = () => {\n    return (\n      <Div>\n        {newType === \"files\" ? (\n          <FileInput\n            setBlobs={(blobs: Asset[]) => {\n              setNewBlobs(blobs);\n            }}\n          />\n        ) : null}\n        {newType === \"camera\" ? (\n          <WebcamCapture\n            withBlob={(blobPath, blob) =>\n              setNewBlobs([\n                {\n                  blobPath,\n                  type: \"image\",\n                  blob,\n                  name: defaultAssetNameWithToken,\n                  sizeBytes: blob.size,\n                  uploadProgress: 0,\n                },\n              ])\n            }\n          />\n        ) : null}\n        {newType === \"recordAudio\" ? (\n          <MediaRecorder\n            type=\"audio\"\n            withBlob={(blobPath, blob) =>\n              setNewBlobs([\n                {\n                  blobPath,\n                  type: \"audio\",\n                  blob,\n                  name: defaultAssetNameWithToken,\n                  uploadProgress: 0,\n                  sizeBytes: blob.size,\n                },\n              ])\n            }\n          />\n        ) : null}\n        {newType === \"recordVideo\" ? (\n          <MediaRecorder\n            type=\"video\"\n            withBlob={(blobPath, blob) =>\n              setNewBlobs([\n                {\n                  blobPath,\n                  type: \"video\",\n                  blob,\n                  name: defaultAssetNameWithToken,\n                  sizeBytes: blob.size,\n                  uploadProgress: 0,\n                },\n              ])\n            }\n          />\n        ) : null}\n\n        {newType === \"recordScreen\" ? (\n          <MediaRecorder\n            type=\"screen\"\n            withBlob={(blobPath, blob) =>\n              setNewBlobs([\n                {\n                  blobPath,\n                  type: \"video\",\n                  blob,\n                  name: defaultAssetNameWithToken,\n                  sizeBytes: blob.size,\n                  uploadProgress: 0,\n                },\n              ])\n            }\n          />\n        ) : null}\n\n        {newType === \"project-media\" ? <SelectMedia source=\"project\" /> : null}\n        {newType === \"p2p-media\" ? <SelectMedia source=\"p2p\" /> : null}\n        {newType === \"google-images\" ? <SelectMedia source=\"google\" /> : null}\n        {newType === \"giphy\" ? <SelectMedia source=\"giphy\" /> : null}\n        {newType === \"unsplashed\" ? <SelectMedia source=\"unsplashed\" /> : null}\n        {newType === \"youtube\" ? <SelectMedia source=\"youtube\" /> : null}\n      </Div>\n    );\n  };\n\n  return (\n    <Div className=\"w-96\">\n      {newType === null || !!defaultNewType ? renderAssets() : null}\n      {newType !== null || !!defaultNewType ? renderNavigation() : null}\n      {renderSpecificAssetInput()}\n    </Div>\n  );\n}",
  "name": "AssetInput",
  "slug": "asset-input",
  "parameters": [],
  "description": "Usage possible in: form, writer-ui, anywhere else (custom)\n\nSupports\n\n- audio recording\n- file upload (multiple possible)\n- camera (taking a picture)\n- video camera (taking a video)",
  "returnType": {
    "rawType": "JSX.Element",
    "typeDefinition": {
      "optional": false,
      "$ref": "#/definitions/JSX.Element"
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 12,
  "size": {
    "characters": 15837,
    "lines": 503,
    "bytes": 15865,
    "bytesPerCharacter": 1.001768011618362,
    "charactersPerLine": 31,
    "linesPerFile": 503,
    "numberOfFiles": 1
  },
  "id": "vthenhrixjqnhhmzubzuqjzk"
}