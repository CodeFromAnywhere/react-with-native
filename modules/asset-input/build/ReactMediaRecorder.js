"use strict";
/**
NB: taken directly from https://github.com/0x006F/react-media-recorder

Fixed the crash by catching it:

Error: There is already an encoder stored which handles exactly the same mime types.

This probably happens because the encoder gets connected more than once if you try to record something another time on the same page...

It shouldn't throw though, because the whole thing simply still works fine!
 */var __awaiter=this&&this.__awaiter||function(e,r,t,n){return new(t||(t=Promise))((function(o,a){function c(e){try{u(n.next(e))}catch(e){a(e)}}function i(e){try{u(n.throw(e))}catch(e){a(e)}}function u(e){var r;e.done?o(e.value):(r=e.value,r instanceof t?r:new t((function(e){e(r)}))).then(c,i)}u((n=n.apply(e,r||[])).next())}))},__generator=this&&this.__generator||function(e,r){var t,n,o,a,c={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function i(a){return function(i){return function(a){if(t)throw new TypeError("Generator is already executing.");for(;c;)try{if(t=1,n&&(o=2&a[0]?n.return:a[0]?n.throw||((o=n.return)&&o.call(n),0):n.next)&&!(o=o.call(n,a[1])).done)return o;switch(n=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return c.label++,{value:a[1],done:!1};case 5:c.label++,n=a[1],a=[0];continue;case 7:a=c.ops.pop(),c.trys.pop();continue;default:if(!(o=c.trys,(o=o.length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){c=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){c.label=a[1];break}if(6===a[0]&&c.label<o[1]){c.label=o[1],o=a;break}if(o&&c.label<o[2]){c.label=o[2],c.ops.push(a);break}o[2]&&c.ops.pop(),c.trys.pop();continue}a=r.call(e,c)}catch(e){a=[6,e],n=0}finally{t=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,i])}}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReactMediaRecorder=exports.useReactMediaRecorder=exports.RecorderErrors=void 0;var RecorderErrors,extendable_media_recorder_1=require("extendable-media-recorder"),react_1=require("react"),extendable_media_recorder_wav_encoder_1=require("extendable-media-recorder-wav-encoder");function useReactMediaRecorder(e){var r=this,t=e.audio,n=void 0===t||t,o=e.video,a=void 0!==o&&o,c=e.onStop,i=void 0===c?function(){return null}:c,u=e.onStart,s=void 0===u?function(){return null}:u,d=e.blobPropertyBag,l=e.screen,f=void 0!==l&&l,p=e.mediaRecorderOptions,v=void 0===p?void 0:p,_=e.customMediaStream,b=void 0===_?null:_,R=e.stopStreamsOnStop,w=void 0===R||R,m=e.askPermissionOnMount,h=void 0!==m&&m,g=(0,react_1.useRef)(null),y=(0,react_1.useRef)([]),E=(0,react_1.useRef)(null),M=(0,react_1.useState)("idle"),x=M[0],k=M[1],S=(0,react_1.useState)(!1),T=S[0],O=S[1],N=(0,react_1.useState)(void 0),A=N[0],D=N[1],U=(0,react_1.useState)("NONE"),j=U[0],B=U[1];(0,react_1.useEffect)((function(){var e=void 0;
// NB: need to clean it up!
return __awaiter(r,void 0,void 0,(function(){var r;return __generator(this,(function(t){switch(t.label){case 0:return t.trys.push([0,3,,4]),[4/*yield*/,(0,extendable_media_recorder_wav_encoder_1.connect)()];case 1:
// NB: try to connect, if it fails, don't crash, just assume it already is there
return e=t.sent(),[4/*yield*/,(0,extendable_media_recorder_1.register)(e)];case 2:return t.sent(),[3/*break*/,4];case 3:return r=t.sent(),console.log("errrie",r),[3/*break*/,4];case 4:return[2/*return*/]}}))})),function(){e&&(0,extendable_media_recorder_wav_encoder_1.disconnect)(e)}}),[]);var L=(0,react_1.useCallback)((function(){return __awaiter(r,void 0,void 0,(function(){var e,r,t,o;return __generator(this,(function(c){switch(c.label){case 0:k("acquiring_media"),e={audio:"boolean"==typeof n?!!n:n,video:"boolean"==typeof a?!!a:a},c.label=1;case 1:return c.trys.push([1,9,,10]),b?(E.current=b,[3/*break*/,8]):[3/*break*/,2];case 2:return f?[4/*yield*/,window.navigator.mediaDevices.getDisplayMedia({video:a||!0})]:[3/*break*/,6];case 3:return(r=c.sent()).getVideoTracks()[0].addEventListener("ended",(function(){F()})),n?[4/*yield*/,window.navigator.mediaDevices.getUserMedia({audio:n})]:[3/*break*/,5];case 4:c.sent().getAudioTracks().forEach((function(e){return r.addTrack(e)})),c.label=5;case 5:return E.current=r,[3/*break*/,8];case 6:return[4/*yield*/,window.navigator.mediaDevices.getUserMedia(e)];case 7:t=c.sent(),E.current=t,c.label=8;case 8:return k("idle"),[3/*break*/,10];case 9:return o=c.sent(),B(o.name),k("idle"),[3/*break*/,10];case 10:return[2/*return*/]}}))}))}),[n,a,f]);(0,react_1.useEffect)((function(){if(!window.MediaRecorder)throw new Error("Unsupported Browser");if(f&&!window.navigator.mediaDevices.getDisplayMedia)throw new Error("This browser doesn't support screen capturing");var e=function(e){var r=navigator.mediaDevices.getSupportedConstraints(),t=Object.keys(e).filter((function(e){return!r[e]}));t.length>0&&console.error("The constraints ".concat(t.join(",")," doesn't support on this browser. Please check your ReactMediaRecorder component."))};return"object"==typeof n&&e(n),"object"==typeof a&&e(a),v&&v.mimeType&&(MediaRecorder.isTypeSupported(v.mimeType)||console.error("The specified MIME type you supplied for MediaRecorder doesn't support this browser")),!E.current&&h&&L(),function(){E.current&&E.current.getTracks().forEach((function(e){return e.clone().stop()}))}}),[n,f,a,L,v,h]);
// Media Recorder Handlers
var P=function(e){var r=e.data;y.current.push(r)},q=function(){s()},C=function(){var e=y.current[0],r=Object.assign({type:e.type},d||(a?{type:"video/mp4"}:{type:"audio/wav"})),t=new Blob(y.current,r),n=URL.createObjectURL(t);k("stopped"),D(n),i(n,t)},V=function(e){O(e),E.current&&E.current.getAudioTracks().forEach((function(r){return r.enabled=!e}))},F=function(){g.current&&"inactive"!==g.current.state&&(k("stopping"),g.current.stop(),w&&E.current&&E.current.getTracks().forEach((function(e){return e.stop()})),y.current=[])};return{error:RecorderErrors[j],muteAudio:function(){return V(!0)},unMuteAudio:function(){return V(!1)},startRecording:function(){return __awaiter(r,void 0,void 0,(function(){return __generator(this,(function(e){switch(e.label){case 0:return B("NONE"),E.current?[3/*break*/,2]:[4/*yield*/,L()];case 1:e.sent(),e.label=2;case 2:return E.current?E.current.getTracks().some((function(e){return"ended"===e.readyState}))?[4/*yield*/,L()]:[3/*break*/,4]:[3/*break*/,5];case 3:e.sent(),e.label=4;case 4:
// User blocked the permissions (getMediaStream errored out)
if(!E.current.active)return[2/*return*/];g.current=new extendable_media_recorder_1.MediaRecorder(E.current,v||void 0),g.current.ondataavailable=P,g.current.onstop=C,g.current.onstart=q,g.current.onerror=function(){B("NO_RECORDER"),k("idle")},g.current.start(),k("recording"),e.label=5;case 5:return[2/*return*/]}}))}))},pauseRecording:function(){g.current&&"recording"===g.current.state&&(k("paused"),g.current.pause())},resumeRecording:function(){g.current&&"paused"===g.current.state&&(k("recording"),g.current.resume())},stopRecording:F,mediaBlobUrl:A,status:x,isAudioMuted:T,previewStream:E.current?new MediaStream(E.current.getVideoTracks()):null,previewAudioStream:E.current?new MediaStream(E.current.getAudioTracks()):null,clearBlobUrl:function(){A&&URL.revokeObjectURL(A),D(void 0),k("idle")}}}!function(e){e.AbortError="media_aborted",e.NotAllowedError="permission_denied",e.NotFoundError="no_specified_media_found",e.NotReadableError="media_in_use",e.OverconstrainedError="invalid_media_constraints",e.TypeError="no_constraints",e.NONE="",e.NO_RECORDER="recorder_error"}(RecorderErrors=exports.RecorderErrors||(exports.RecorderErrors={})),exports.useReactMediaRecorder=useReactMediaRecorder;var ReactMediaRecorder=function(e){return e.render(useReactMediaRecorder(e))};exports.ReactMediaRecorder=ReactMediaRecorder;
//# sourceMappingURL=ReactMediaRecorder.js.map