{
  "createdAt": 1669055602443,
  "updatedAt": 1669055602443,
  "deletedAt": 0,
  "createdFirstAt": 1669055602443,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "getTsStatements",
  "slug": "get-ts-statements",
  "operationRelativeTypescriptFilePath": "src/getTsStatements.ts",
  "type": {
    "rawType": "(sourceFile: import(\"/Users/king/King/operations/node_modules/ts-morph/lib/ts-morph\").SourceFile, tsInterfaces: any[], operationRelativeTypescriptFilePath: string, fileContent: string) => unknown",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (\n  sourceFile: SourceFile,\n  /**\n   * NB: we require all interfaces here across the monorepo because the ones indexed by the schema generator aren't complete.\n   */\n  tsInterfaces: Creation<TsInterface>[],\n  operationRelativeTypescriptFilePath: string,\n  fileContent: string\n) => {\n  const tsVariables: Creation<TsVariable>[] = sourceFile\n    .getVariableStatements()\n    .map((variableStatement) => {\n      const declarations = variableStatement.getDeclarations();\n      const inits = declarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const name = declarations[0]?.getName();\n      const value = inits[0]?.getText();\n\n      const isExported = variableStatement.isExported();\n\n      const classification = variableStatement\n        .getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const description = variableStatement\n        .getJsDocs()\n        .map((x) => x.getText())\n        .map(stripComment)\n        .join(\"\\n\\n\");\n\n      const slug = kebabCase(name);\n\n      const type = getTypeInfo(declarations[0]?.getType());\n      const tsVariable: Creation<TsVariable> = {\n        classification,\n        comments: [],\n        isExported,\n        name,\n        slug,\n        operationRelativeTypescriptFilePath,\n        type,\n        value,\n        description,\n      };\n      return tsVariable;\n    });\n\n  const morphVars: VariableDeclarationInfo[] = sourceFile\n    .getStatements()\n    .map((x) => {\n      const variableDeclarations = x\n        .asKind(SyntaxKind.VariableStatement)\n        ?.getDeclarations();\n\n      if (!variableDeclarations || variableDeclarations.length === 0) return;\n\n      const explicitTypeName = variableDeclarations\n        .map((x) => x.getTypeNode()?.getText())\n        .filter(notEmpty)[0];\n      return {\n        explicitTypeName,\n        isExported: variableDeclarations[0].isExported(),\n        variableDeclarations,\n        // NB: if this is a VariableStatement\n        kindName: x.getKindName(),\n\n        // NB: this is how we can check if it's an arrow function (declaration Initializer Kind Names Includes Arrow Function)\n        isArrowFunction: variableDeclarations\n          .map((v) => v.getInitializer())\n          .map((x) => x?.getKindName())\n          .includes(\"ArrowFunction\"),\n\n        // NB: if it's a variable, we can get the name like this\n        names: variableDeclarations.map((x) => x.getName()),\n\n        comments: x\n          .getLeadingCommentRanges()\n          .map((x) => x.getText())\n          .map(stripComment),\n      };\n    })\n    .filter(notEmpty);\n\n  // const stringLiterals = morphVars.filter((v) => !v.isArrowFunction);\n\n  /*\n   * \n   * This was the old way of parsing tsVariables, but it was not finding the comments.\n   * \n   * \n  const tsVariables: Creation<TsVariable>[] = stringLiterals\n    .map((v) => {\n      const inits = v.variableDeclarations\n        .map((x) => x.getInitializer())\n        .filter(notEmpty);\n\n      const initComments = inits\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n      const variableDeclarationComments = v.variableDeclarations\n        .map((x) => x.getLeadingCommentRanges().map((x) => x.getText()))\n        .flat()\n        .join(\"\\n\\n\");\n\n      const name = v.names[0] || \"__NO_NAME__\";\n      const slug = kebabCase(name);\n      const value =\n        inits.map((x) => x.getText()).filter(notEmpty)[0] || \"__NO_VALUE__\";\n\n      // TODO: TEST, should return const, var or let\n      const classification = v.variableDeclarations[0]\n        .getVariableStatement()\n        ?.getDeclarationKind()\n        .toString()\n        .toLowerCase() as TsVariable[\"classification\"];\n\n      const variableDeclaration = v.variableDeclarations?.[0];\n\n      if (!variableDeclaration) {\n        return;\n      }\n\n      const variableComments = getAllComments(\n        variableDeclaration,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n\n      const statementComments: Creation<TsComment>[] = variableDeclaration\n        .getDescendantStatements()\n        .map((x) => {\n          const allComments = getAllComments(\n            x,\n            fileContent,\n            operationRelativeTypescriptFilePath\n          );\n          return allComments;\n        })\n        .flat();\n\n      const comments = variableComments\n        ? [...variableComments, ...statementComments]\n        : statementComments;\n\n      const isExported = v.isExported;\n\n      console.log({ comments, initComments, variableDeclarationComments });\n      const description = undefined;\n      const variable: Creation<TsVariable> = {\n        description,\n        isExported,\n        operationRelativeTypescriptFilePath,\n        comments,\n        name,\n        slug,\n        value,\n        // NB: still using typeToSchema here, is there another way?\n        type: getTypeInfo(variableDeclaration.getType()),\n        classification,\n      };\n      return variable;\n    })\n    .filter(notEmpty);\n    */\n\n  const morphFunctions = sourceFile.getFunctions();\n  const arrowFunctionVars = morphVars.filter((v) => v.isArrowFunction);\n\n  const arrowFunctions: Creation<TsFunction>[] = arrowFunctionVars\n    .map((v) => {\n      const isExported = v.isExported;\n\n      const arrowFunction = v.variableDeclarations?.map((x) =>\n        x.getInitializer()?.asKind(SyntaxKind.ArrowFunction)\n      )[0];\n\n      if (!arrowFunction) {\n        log(\"Should never get here, arrow function not found\", {\n          type: \"error\",\n        });\n        return;\n      }\n\n      const description = v.comments.join(\"\\n\\n\");\n\n      const name = v.names?.[0] || \"no name\";\n\n      const returnType = getTypeInfo(\n        arrowFunction.getReturnType().getApparentType()\n      );\n      const functionText = arrowFunction.getFullText();\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n        isExported,\n        isApiExposed: true,\n        groupAuthorization: {},\n        explicitTypeName: v.explicitTypeName,\n\n        operationRelativeTypescriptFilePath,\n\n        // TODO:\n        commentsInside: [],\n        rawText: functionText,\n        name,\n        slug: kebabCase(name),\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        description,\n        returnType,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n\n        // TODO: isolate the size calculations...\n\n        // size of function including comments\n        size: getSizeSummary(fullText),\n\n        // split it up\n        //codeSize: {},\n        //commentSize:{},\n\n        // cumulativeCodeSize:{},\n        // cumulativeCommentSize:{},\n        // cumulativeSize:{},\n      };\n\n      return fn;\n    })\n    .filter(notEmpty);\n\n  const regularFunctions: Creation<TsFunction>[] = morphFunctions.map(\n    (functionDeclaration) => {\n      const returnType = getTypeInfo(\n        functionDeclaration.getReturnType().getApparentType()\n      );\n\n      const functionText = functionDeclaration.getFullText();\n\n      const description = functionDeclaration\n        .getJsDocs()\n        .map((x) => x.getFullText())\n        .join(\"\\n\\n\");\n\n      const fullText = functionText.concat(description);\n\n      const parsedDescription = parseFrontmatterMarkdownString(description);\n      const frontmatter = parsedDescription.parameters;\n      const frontmatterParameters =\n        getFrontmatterFunctionParameters(frontmatter);\n\n      const name = functionDeclaration.getName() || \"__anonymous__\";\n\n      const runEveryPeriod: RunEveryPeriodEnum | undefined = undefined;\n      const fn: Creation<TsFunction> = {\n        ...frontmatterParameters,\n\n        name,\n        runEveryPeriod,\n\n        slug: kebabCase(name),\n        isExported: functionDeclaration.isExported(),\n        operationRelativeTypescriptFilePath,\n        groupAuthorization: {},\n        // TODO:\n        commentsInside: [],\n        // function metadata\n        // function info\n        description,\n        parameters: getParametersFromInterfaces(name, tsInterfaces),\n        returnType,\n        size: getSizeSummary(fullText),\n        rawText: functionText,\n        maxIndentationDepth: getMaxIndentationDepth(functionText),\n      };\n\n      return fn;\n    }\n  );\n\n  const tsFunctions = arrowFunctions.concat(regularFunctions);\n\n  return { tsFunctions, tsVariables };\n}",
  "description": "Gets functions and variables from a tsmorph sourcefile",
  "id": "cbvphcltovmaarovsiteshhv"
}