{
  "createdAt": 1669055617127,
  "updatedAt": 1669055617127,
  "deletedAt": 0,
  "createdFirstAt": 1669055617127,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/indexTypescriptFile.ts",
  "commentsInside": [],
  "rawText": " async (\n  project: Project,\n  file: CompleteOperationPathParse,\n  projectRoot: string\n) => {\n  const problems: string[] = [];\n\n  const { filePath, operationName, operationRelativeTypescriptFilePath } = file;\n  if (!operationName) return;\n\n  // console.log(`indexing file`, {\n  //   operationName,\n  //   filePath,\n  //   operationRelativeTypescriptFilePath,\n  // });\n  // END VALIDATION\n\n  const fileContent = await fs.readFile(filePath, \"utf8\");\n\n  //select correct SourceFile from tsmorph project\n  const sourceFile = project.getSourceFile(filePath);\n\n  if (!sourceFile) {\n    const problem = `couldn't load file ${filePath}`;\n    problems.push(problem);\n\n    await db.update(\n      \"Operation\",\n      (item) => item.name === operationName,\n      (old) =>\n        mergeNestedObject(old, {\n          operation: { buildResultIndexed: { indexInteracesErrors: problems } },\n        }),\n      { operationName }\n    );\n\n    log(problem, { type: \"error\" });\n    return;\n  }\n\n  const newTsInterfaces = await findAndUpsertTsInterfaces({\n    filePath,\n    sourceFile,\n    operationName,\n    projectRoot,\n  });\n\n  if (!newTsInterfaces) {\n    log(\"Shouldn't happen but tsInterfaces is undefined here...\");\n    return;\n  }\n\n  const allTsInterfaces = await db.get(\"TsInterface\");\n\n  const allWithNewTsInterfaces = [\n    ...newTsInterfaces,\n    ...allTsInterfaces,\n  ].filter(onlyUnique2<Creation<TsInterface>>((a, b) => a.name === b.name));\n  // NB: interfaces are a prerequisite for function...\n\n  // console.log({\n  //   newTsInterfaces: newTsInterfaces.length,\n  //   allTsInterfaces: allTsInterfaces.length,\n  //   allWithNewTsInterfacesUnique: allWithNewTsInterfaces.length,\n  // });\n  // TODO:\n  const tsLintWarnings: TsLintWarning[] = [];\n\n  // TODO: get main comment from top of file or associated md\n  const mainComment = undefined;\n  const pathMetaData = await calculatePathMetaData(filePath);\n\n  const { tsFunctions, tsVariables } = await getTsStatements(\n    sourceFile,\n    allWithNewTsInterfaces,\n    operationRelativeTypescriptFilePath,\n    fileContent\n  );\n\n  // gets all top level statements\n  const topLevelComments: Creation<TsComment>[] = sourceFile\n    .getStatementsWithComments()\n    .map((x) => {\n      const comments = getAllComments(\n        x,\n        fileContent,\n        operationRelativeTypescriptFilePath\n      );\n      return comments;\n    })\n    .flat();\n\n  const functionComments: Creation<TsComment>[] = tsFunctions\n    .map((f) => f.commentsInside)\n    .flat();\n  const interfaceComments: Creation<TsComment>[] = newTsInterfaces\n    .map((f) => f.commentsInside)\n    .flat();\n  const variableComments: Creation<TsComment>[] = tsVariables\n    .map((f) => f.comments)\n    .flat();\n\n  // TODO: get all top level comments from the statements, but also get all comments already found in functions, variables, and interfaces, put together.\n  const tsComments: Creation<TsComment>[] = [\n    topLevelComments,\n    functionComments,\n    interfaceComments,\n    variableComments,\n  ].flat();\n\n  // Inserting all results into the database...\n\n  // @ts-ignore\n  await db.remove(\n    \"TsFunction\",\n    (fn) =>\n      fn.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsFunctions.map((x) => x.name).includes(fn.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  // @ts-ignore\n  await db.upsert(\"TsFunction\", tsFunctions, {\n    operationName,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsVariable\",\n    (v) =>\n      v.operationRelativeTypescriptFilePath ===\n        operationRelativeTypescriptFilePath &&\n      !tsVariables.map((x) => x.name).includes(v.name),\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsVariable\", tsVariables, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n\n  await db.remove(\n    \"TsComment\",\n    (c) =>\n      c.operationRelativeTypescriptFilePath ===\n      operationRelativeTypescriptFilePath,\n    { operationName, manualProjectRoot: projectRoot }\n  );\n  await db.upsert(\"TsComment\", tsComments, {\n    operationName,\n    removeUntouched: true,\n    manualProjectRoot: projectRoot,\n  });\n}",
  "name": "indexTypescriptFile",
  "slug": "index-typescript-file",
  "parameters": [
    {
      "name": "project",
      "schema": {
        "$ref": "#/definitions/Project"
      },
      "simplifiedSchema": {
        "fullComment": "Project that holds source files.",
        "properties": [],
        "type": "object"
      },
      "required": true
    },
    {
      "name": "file",
      "schema": {
        "$ref": "#/definitions/CompleteOperationPathParse"
      },
      "simplifiedSchema": {
        "fullComment": "",
        "properties": [
          {
            "name": "filePath",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "relativeOperationBasePathFromProjectRoot",
            "required": true,
            "schema": {
              "fullComment": "relative file path from the project-root to the operation (DOES include operation folder)\n\ne.g. /tools/cognition/typescript/index-typescript",
              "type": "string"
            }
          },
          {
            "name": "operationRelativeTypescriptFilePath",
            "required": true,
            "schema": {
              "fullComment": "relative file path from the operation src\n\ne.g. general.ts",
              "type": "string"
            }
          },
          {
            "name": "srcFileId",
            "required": true,
            "schema": {
              "fullComment": "file id (same as operationRelativeTypescriptFilePath but without extension)\n\ne.g. \"general\"\n\nTODO: figure out if this can be omitted",
              "todo": "figure out if this can be omitted",
              "type": "string"
            }
          },
          {
            "name": "operationName",
            "required": false,
            "schema": {
              "fullComment": "operation package.json name",
              "type": "string"
            }
          },
          {
            "name": "operationFolderName",
            "required": true,
            "schema": {
              "fullComment": "operation folder name (by convention, must be identical to operationName, but it could have some mistakes)",
              "type": "string"
            }
          },
          {
            "name": "relativePathFromProjectRoot",
            "required": true,
            "schema": {
              "fullComment": "relative file or folder path from the project root",
              "type": "string"
            }
          }
        ],
        "type": "object"
      },
      "required": true
    },
    {
      "name": "projectRoot",
      "schema": {
        "type": "string"
      },
      "simplifiedSchema": {
        "type": "string"
      },
      "required": true
    }
  ],
  "description": "",
  "returnType": {
    "rawType": "any",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 5,
  "size": {
    "characters": 4183,
    "lines": 154,
    "bytes": 4183,
    "bytesPerCharacter": 1,
    "charactersPerLine": 27,
    "linesPerFile": 154,
    "numberOfFiles": 1
  },
  "id": "vfdlbryofudxkeuoqelyirsl"
}