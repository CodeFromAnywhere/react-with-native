"use strict";var __assign=this&&this.__assign||function(){return __assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},__assign.apply(this,arguments)},__awaiter=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(s,o){function i(e){try{l(r.next(e))}catch(e){o(e)}}function a(e){try{l(r.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,a)}l((r=r.apply(e,t||[])).next())}))},__generator=this&&this.__generator||function(e,t){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&o[0]?r.return:o[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,o[1])).done)return s;switch(r=0,s&&(o=[2&o[0],s.value]),o[0]){case 0:case 1:s=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!(s=i.trys,(s=s.length>0&&s[s.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!s||o[1]>s[0]&&o[1]<s[3])){i.label=o[1];break}if(6===o[0]&&i.label<s[1]){i.label=s[1],s=o;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(o);break}s[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=s=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},__rest=this&&this.__rest||function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n},__spreadArray=this&&this.__spreadArray||function(e,t,n){if(n||2===arguments.length)for(var r,s=0,o=t.length;s<o;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.exploreMultiple=exports.explorePreset=exports.exploreOperationFolders=exports.exploreGitRepoFolders=exports.findAllDotGitFolders=exports.findAllPackages=exports.generatedFolders=exports.findFilesRecursively=exports.explore=exports.determineFileType=exports.fileTypes=exports.allowedSearchContentExtensions=exports.extensions=exports.jsonExtensions=exports.markdownExtensions=exports.typescriptExtensions=exports.jsonExtensionsConst=exports.markdownExtensionsConst=exports.typescriptExtensionsConst=void 0;var fs_util_1=require("fs-util"),read_json_file_1=require("read-json-file"),fs_util_2=require("fs-util"),fs_util_3=require("fs-util"),js_util_1=require("js-util"),fs_util_4=require("fs-util"),markdown_parse_js_1=require("markdown-parse-js"),get_path_1=require("get-path");exports.typescriptExtensionsConst=["ts","tsx"],exports.markdownExtensionsConst=["md","mdx"],exports.jsonExtensionsConst=["json"],exports.typescriptExtensions=__spreadArray([],exports.typescriptExtensionsConst,!0),exports.markdownExtensions=__spreadArray([],exports.markdownExtensionsConst,!0),exports.jsonExtensions=__spreadArray([],exports.jsonExtensionsConst,!0),exports.extensions={code:exports.typescriptExtensions,data:exports.jsonExtensions,text:exports.markdownExtensions},exports.allowedSearchContentExtensions=__spreadArray(__spreadArray(__spreadArray([],exports.typescriptExtensions,!0),exports.markdownExtensions,!0),exports.jsonExtensions,!0),exports.fileTypes=Object.keys(exports.extensions);
/**
 * type checker for a string to be an extension that can be searched for
 */
var isSearchContentExtension=function(e){return exports.allowedSearchContentExtensions.map((function(e){return e})).includes(e)},determineFileType=function(e){var t=fs_util_2.path.parse(e).ext.substring(1);if(!isSearchContentExtension(t))return null;var n=exports.fileTypes.findIndex((function(e){return exports.extensions[e].includes(t)}));return exports.fileTypes[n]};
/**
 * returns the file type or null if it's unknown
 */exports.determineFileType=determineFileType;
/**
 *
 */
var getOutline=function(e){return console.log("outline is currently just filename"),e.split("/").pop()},isMatch=function(e){var t=e.exact,n=e.searchContender,r=e.searches;return 0===r.length||(t?r.includes(n):r.find((function(e){return n.includes(e)})))},getContents=function(e){return __awaiter(void 0,void 0,void 0,(function(){var t,n;return __generator(this,(function(r){switch(r.label){case 0:return t=(0,fs_util_3.getExtension)(e),isSearchContentExtension(t)?"json"!==t?[3/*break*/,1]:[2/*return*/,(0,read_json_file_1.readJsonFile)(e)]:[2/*return*/];case 1:return exports.markdownExtensions.includes(t)?[4/*yield*/,fs_util_1.fs.readFile(e,"utf8")]:[3/*break*/,3];case 2:return n=r.sent(),[2/*return*/,(0,markdown_parse_js_1.mdToJsonParse)(n)];case 3:return[2/*return*/,fs_util_1.fs.readFile(e,"utf8")]}}))}))},explore=function(e){return __awaiter(void 0,void 0,void 0,(function(){var t,n,r,s=e.basePath,o=e.searchLevel,i=void 0===o?"fileName":o,a=e.debug,l=__rest(e,["basePath","searchLevel","debug"]);return __generator(this,(function(e){switch(e.label){case 0:return t=function(e){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return[4/*yield*/,("outline"===i||"full"===i?fs_util_4.canRead:fs_util_4.canSee)(e)];case 1:return[2/*return*/,t.sent()]}}))}))},n=(0,js_util_1.makeArray)(s||(0,get_path_1.getProjectRoot)()).filter(fs_util_1.fs.existsSync).filter(t),a&&console.log("finding files in ".concat(n.join(","))),r=n.map((function(e){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(t){return[2/*return*/,(0,exports.findFilesRecursively)(__assign({basePath:e,searchLevel:i,debug:a},l))]}))}))})),[4/*yield*/,Promise.all(r)];case 1:return[2/*return*/,e.sent().flat()]}}))}))};exports.explore=explore;
/**
Explores your files with many possibilities.

NB: this function only searches one basePath, while explore can do multiple

TODO: since this not only finds files but also explores them, naming should be exploreFilesRecursively, probably.

TODO: TextJson[] is a bit weird name for the resulting type interface...
*/
var findFilesRecursively=function(e){return __awaiter(void 0,void 0,void 0,(function(){var t,n,r,s,o,i,
//booleans:
a,l,c,u,d,p,x,f,_,h,g,v,m,b,y;return __generator(this,(function(w){switch(w.label){case 0:return t=e.basePath,n=e.ignore,r=e.searchLevel,s=e.extension,o=e.subExtension,i=e.search,a=e.includeFoldersWithResults,l=e.doNotExploreMatch,c=e.doNotExploreChildFolders,u=e.debug,d=e.exact,p=e.includeStats,x=e.includeMetaData,f=e.cancelRecursionOn,_=(0,js_util_1.makeArray)(o),h=(0,js_util_1.makeArray)(s),g=(0,js_util_1.makeArray)(i),v=(0,js_util_1.makeArray)(n),[4/*yield*/,fs_util_1.fs.readdir(t,{withFileTypes:!0,encoding:"utf8"})];case 1:
// if contents should not be explored, return an empty array
return m=w.sent(),b=m.map((function(e){return fs_util_2.path.join(t,e.name)})),(null==f?void 0:f(b))?[2/*return*/,a?[{path:t,isCancelRecursionResult:!0}]:[]]:(u&&console.log("contents contains ".concat(m.length," files/folders")),y=m.map((function(e){return __awaiter(void 0,void 0,void 0,(function(){var m,b,y,w,E,F,P,j,k,C,A,O,R,S,L,M,N,T,D,G,q,J;return __generator(this,(function(I){switch(I.label){case 0:
// don't check files if search level is folder
return"folder"===r&&e.isFile()?[2/*return*/,null]:
//if dir/file name should be ignored, skip it
v.includes(e.name)?(u&&console.log("Ignoring",e.name),[2/*return*/,null]):
// if we want specific sub-extensions and this file isn't one of them, return
e.isFile()&&_&&_.length>0&&!_.find((function(t){return(0,fs_util_3.getSubExtension)(e.name)===t}))?(u&&console.log("ignoring ".concat(e.name," because of subextension mismatch")),[2/*return*/,null]):
// if we want specific extensions and this file isn't one of them, return
e.isFile()&&h&&h.length>0&&!h.find((function(t){return(0,fs_util_3.getExtension)(e.name)===t}))?(u&&console.log("ignoring ".concat(e.name," because of extension mismatch")),[2/*return*/,null]):(m=fs_util_2.path.join(t,e.name),e.isFile()?(b=(0,fs_util_3.getExtension)(e.name)||"",y=exports.jsonExtensions.includes(b),exports.typescriptExtensions.includes(b),w=exports.markdownExtensions.includes(b),"folder"!==r?[3/*break*/,1]:(E=e.name,[3/*break*/,11])):[3/*break*/,18]);case 1:return"fileName"!==r?[3/*break*/,2]:(F=e.name,[3/*break*/,10]);case 2:return"filePath"!==r&&isSearchContentExtension(b)?[3/*break*/,3]:(P=m,[3/*break*/,9]);case 3:return"outline"!==r?[3/*break*/,4]:(j=getOutline(m),[3/*break*/,8]);case 4:return"full"!==r?[3/*break*/,6]:[4/*yield*/,getContents(m)];case 5:return k=I.sent(),[3/*break*/,7];case 6:k="SHOULD_NEVER_HAPPEN",I.label=7;case 7:j=k,I.label=8;case 8:P=j,I.label=9;case 9:F=P,I.label=10;case 10:E=F,I.label=11;case 11:return T=E,u&&console.log("searchContender: ".concat(T)),D=isMatch({exact:d,searchContender:T,searches:g}),C=y&&"full"===r?getContents(m):void 0,w&&"full"===r?[4/*yield*/,getContents(m)]:[3/*break*/,13];case 12:return O=I.sent(),[3/*break*/,14];case 13:O=void 0,I.label=14;case 14:return A=O,R=void 0,p?[4/*yield*/,fs_util_1.fs.stat(m)]:[3/*break*/,16];case 15:return L=I.sent(),[3/*break*/,17];case 16:L=void 0,I.label=17;case 17:return S=L,u&&console.log("".concat(e.name,"? match ").concat(D)),[2/*return*/,D?[{path:m,json:C,markdownJson:A,typescriptJson:R,stats:S}]:null];case 18:return!e.isDirectory()||c?[3/*break*/,21]:(M=[],N=!0,"folder"===r&&(T=e.name,(D=isMatch({searchContender:T,exact:d,searches:g}))&&(M.push({path:m}),N=!l)),N?(G=fs_util_2.path.join(t,e.name),[4/*yield*/,(0,exports.findFilesRecursively)({basePath:G,extension:s,search:i,searchLevel:r,subExtension:o,ignore:n,debug:u,exact:d,
// NB: I think we just need to fill in everything in the recursion, right?
cancelRecursionOn:f,includeFoldersWithResults:a,includeMetaData:x,includeStats:p,doNotExploreChildFolders:c,doNotExploreMatch:l})]):[3/*break*/,20]);case 19:(q=I.sent()).length>0&&(M=M.concat(q),a&&(void 0,J={path:G,metaData:undefined},M.push(J))),I.label=20;case 20:return[2/*return*/,M];case 21:return[2/*return*/,null]}}))}))})),[4/*yield*/,Promise.all(y)]);case 2:return[2/*return*/,w.sent().filter(js_util_1.notEmpty).flat()]}}))}))};exports.findFilesRecursively=findFilesRecursively,exports.generatedFolders=["node_modules","build",".next",".git"];
/**
 * Finds all package.json's everywhere. also in /tools, but this is to be expected.
 *
 * TODO: `stopRecursionAfterMatch` never worked, so I just removed it... the behavior now is that it also explores folders that are in a folder with a `package.json`, unless that foldername is ignored. For now it's fine, but this could easily create an ineficiency if there's a lot of data in an operation or something...
 *
 * TODO: We should be careful with ignoring all these folders... what if we use those folders outside of operations? This could have unexpected behavior. We either need to lint for these foldernames not to be used, or we need to make sure to only ignore it if we encounter a package.json
 */
var findAllPackages=function(e){return(0,exports.explore)({basePath:(null==e?void 0:e.basePath)||(0,get_path_1.getPathsWithOperations)(),search:"package.json",exact:!0,extension:"json",searchLevel:"fileName",ignore:exports.generatedFolders.concat(["src","assets","data"])})};exports.findAllPackages=findAllPackages;var findAllDotGitFolders=function(e){return(0,exports.explore)({basePath:null==e?void 0:e.basePath,search:".git",exact:!0,searchLevel:"folder",doNotExploreMatch:!0,
// I guess we can assume there will never be git folders inside an operation on a deeper level, that would be strange... Therefore, these can be ignored
ignore:["node_modules","build",".next","src","assets","data"]})};exports.findAllDotGitFolders=findAllDotGitFolders;
/**
 find all active git folders (folders having `.git`)
 */
var exploreGitRepoFolders=function(e){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return[4/*yield*/,(0,exports.findAllDotGitFolders)(e)];case 1:return[2/*return*/,t.sent().map((function(e){return e.path})).map((function(e){return fs_util_2.path.resolve(e,"..")}))]}}))}))};exports.exploreGitRepoFolders=exploreGitRepoFolders;
/**
 find all active operations (folders having `package.json` but also `tsconfig.json`)
 */
var exploreOperationFolders=function(e){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return[4/*yield*/,(0,exports.findAllPackages)({basePath:null==e?void 0:e.basePath})];case 1:return[2/*return*/,t.sent().map((function(e){return e.path})).map((function(e){return(0,fs_util_3.getFolder)(e)})).filter((function(e){return fs_util_1.fs.existsSync(fs_util_2.path.join(e,"tsconfig.json"))}))]}}))}))};exports.exploreOperationFolders=exploreOperationFolders;var explorePreset=function(e,t){var n=null==t?void 0:t.basePath,r="packages"===e?[{basePath:n,search:"package.json",exact:!0,extension:"json",ignore:exports.generatedFolders}]:"markdown"===e?[{basePath:n,extension:["md","mdx"],ignore:exports.generatedFolders}]:"todo"===e?// finds all `*.todo.md`,` todo/**/*.md` and returns the path + content
[{basePath:n,extension:["md","mdx"],search:"/todo/",searchLevel:"filePath",ignore:exports.generatedFolders},{basePath:n,extension:["md","mdx"],search:"todo.md",exact:!0,searchLevel:"fileName",ignore:exports.generatedFolders},{basePath:n,extension:["md","mdx"],subExtension:"todo",exact:!1,searchLevel:"fileName",ignore:exports.generatedFolders}]:"docs"===e?[{basePath:n,extension:["md","mdx"],search:"/docs/",searchLevel:"filePath",ignore:exports.generatedFolders},{basePath:n,extension:["md","mdx"],search:"readme.md",exact:!0,searchLevel:"fileName",ignore:exports.generatedFolders},{basePath:n,extension:["md","mdx"],subExtension:["readme"],exact:!1,searchLevel:"fileName",ignore:exports.generatedFolders}]:"src"===e?[{basePath:n,searchLevel:"folder",exact:!0,search:"src",doNotExploreMatch:!0,ignore:exports.generatedFolders}]:[];return(0,exports.exploreMultiple)(r)};exports.explorePreset=explorePreset;
/**
 * DEPRECATED: not sure if we still need it, look up usecases, can prob be replaced now
 */
var exploreMultiple=function(e){return __awaiter(void 0,void 0,void 0,(function(){var t;return __generator(this,(function(n){switch(n.label){case 0:return t=e.map((function(e){return __awaiter(void 0,void 0,void 0,(function(){return __generator(this,(function(t){return[2/*return*/,(0,exports.explore)(e)]}))}))})),[4/*yield*/,Promise.all(t)];case 1:return[2/*return*/,n.sent().flat()]}}))}))};exports.exploreMultiple=exploreMultiple;
//# sourceMappingURL=explore.js.map