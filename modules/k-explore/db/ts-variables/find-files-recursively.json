{
  "createdAt": 1666259118132,
  "updatedAt": 1666259118132,
  "deletedAt": 0,
  "createdFirstAt": 1666259118132,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "findFilesRecursively",
  "slug": "find-files-recursively",
  "operationRelativeTypescriptFilePath": "src/explore.ts",
  "type": {
    "rawType": "(config: any) => Promise<import(\"/Users/king/King/operations/tools/types/code-types/build/TextJson\").TextJson[]>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (\n  config: Omit<SearchConfig, \"basePath\"> & {\n    // this is the only difference compared to the other searchconfig\n    basePath: string;\n  }\n): Promise<TextJson[]> => {\n  const {\n    basePath,\n    ignore,\n    searchLevel,\n    extension,\n    subExtension,\n    search,\n    //booleans:\n    includeFoldersWithResults,\n    doNotExploreMatch,\n    doNotExploreChildFolders,\n    debug,\n    exact,\n    readmeOnTop,\n    includeStats,\n    includeMetaData,\n    cancelRecursionOn,\n  } = config;\n  // NB: we know we only use this function like this\n  const subExtensions = makeArray(subExtension);\n  const extensions = makeArray(extension);\n  const searches = makeArray(search);\n  const ignores = makeArray(ignore);\n\n  const contents = await fs.readdir(basePath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  // NB: if there's a readme and readmeOnTop is true, make sure it ends up on top\n  const readmeIndex = readmeOnTop\n    ? contents.findIndex((x) => x.name.toLowerCase() === \"readme.md\")\n    : -1;\n  const sortedContents: Dirent[] =\n    readmeIndex !== -1\n      ? [contents[readmeIndex], ...removeIndexFromArray(contents, readmeIndex)]\n      : contents;\n\n  const pathArray = sortedContents.map((x) => path.join(basePath, x.name));\n\n  // if contents should not be explored, return an empty array\n  if (cancelRecursionOn?.(pathArray)) {\n    return includeFoldersWithResults\n      ? [{ path: basePath, isCancelRecursionResult: true, isFolder: false }]\n      : [];\n  }\n\n  if (debug)\n    console.log(`contents contains ${sortedContents.length} files/folders`);\n\n  const textJsonPromises: Promise<TextJson[] | null>[] = sortedContents.map(\n    async (dirent) => {\n      // don't check files if search level is folder\n      if (searchLevel === \"folder\" && dirent.isFile()) {\n        return null;\n      }\n\n      //if dir/file name should be ignored, skip it\n      if (ignores.includes(dirent.name)) {\n        if (debug) console.log(\"Ignoring\", dirent.name);\n        return null;\n      }\n\n      // if we want specific sub-extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        subExtensions &&\n        subExtensions.length > 0 &&\n        !subExtensions.find((ext) => getSubExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(\n            `ignoring ${dirent.name} because of subextension mismatch`\n          );\n        return null;\n      }\n\n      // if we want specific extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        extensions &&\n        extensions.length > 0 &&\n        !extensions.find((ext) => getExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(`ignoring ${dirent.name} because of extension mismatch`);\n        return null;\n      }\n\n      const filePath: string = path.join(basePath, dirent.name);\n\n      // if it's a file, we don't go into recursion.\n      if (dirent.isFile()) {\n        const ext = getExtension(dirent.name) || \"\";\n\n        //getting extension\n\n        const isJson = jsonExtensions.includes(ext);\n        const isTypescript = typescriptExtensions.includes(ext);\n        const isMarkdown = markdownExtensions.includes(ext);\n\n        //NB: be careful when ever changing this logic!\n        // It should never get contents when it doesn't need to,\n        // because this is a very heavy operation.\n\n        const searchContender =\n          searchLevel === \"folder\"\n            ? dirent.name\n            : searchLevel === \"fileName\"\n            ? dirent.name\n            : searchLevel === \"filePath\" || !isSearchContentExtension(ext)\n            ? filePath //withoutExtension? dirent.name or filePath??? we also want to match folder names before it, right?\n            : //TODO: is getOutLine() evaluated if it's not an outline? it also seems the default, which I don't like. Test this, it's an important aspect of exploring efficiently.\n            searchLevel === \"outline\"\n            ? getOutline(filePath)!\n            : searchLevel === \"full\"\n            ? await getContents(filePath)\n            : \"SHOULD_NEVER_HAPPEN\";\n\n        if (debug) console.log(`searchContender: ${searchContender}`);\n        const match = isMatch({ exact, searchContender, searches });\n\n        const json: any | undefined =\n          isJson && searchLevel === \"full\" ? getContents(filePath) : undefined;\n\n        const markdownJson: MarkdownParse | undefined =\n          isMarkdown && searchLevel === \"full\"\n            ? // TODO: get markdown parse here\n              await getContents(filePath)\n            : undefined;\n\n        // NB: TODO: we don't do typescript json yet\n        // TODO: I think double special comments (like the above) on a single line isn't indexed yet, is it?\n        const typescriptJson: undefined = isTypescript ? undefined : undefined;\n\n        const stats = includeStats ? await fs.stat(filePath) : undefined;\n\n        if (debug) console.log(`${dirent.name}? match ${match}`);\n        //match found...\n        const matchOrNot: TextJson[] | null = match\n          ? [\n              {\n                path: filePath,\n                json,\n                isFolder: false,\n                markdownJson,\n                typescriptJson,\n                stats,\n              },\n            ]\n          : null;\n        return matchOrNot;\n      }\n\n      // ^ these were all the base cases ^. Now the recursion.\n\n      if (dirent.isDirectory() && !doNotExploreChildFolders) {\n        let results: TextJson[] = [];\n        let shouldRecurse = true;\n        if (searchLevel === \"folder\") {\n          const searchContender = dirent.name;\n          const match = isMatch({ searchContender, exact, searches });\n\n          if (match) {\n            results.push({\n              path: filePath,\n              isFolder: true,\n            });\n            shouldRecurse = !doNotExploreMatch;\n          }\n        }\n\n        /**\n       don't dive into folder if:\n      - we're looking for folders \n      - the folder has matched \n      - we don't explore matches\n      */\n        if (shouldRecurse) {\n          const thisFolderPath = path.join(basePath, dirent.name);\n          const thisFolderResults = await findFilesRecursively({\n            basePath: thisFolderPath,\n            extension,\n            search,\n            searchLevel,\n            subExtension,\n            ignore,\n            debug,\n            exact,\n            // NB: I think we just need to fill in everything in the recursion, right?\n            cancelRecursionOn,\n            includeFoldersWithResults,\n            includeMetaData,\n            includeStats,\n            doNotExploreChildFolders,\n            doNotExploreMatch,\n          });\n\n          if (thisFolderResults.length > 0) {\n            results = results.concat(thisFolderResults);\n\n            if (includeFoldersWithResults) {\n              // NB: we can't show any stats because this fs.stats function only works on files. We could sum all stats recursively\n\n              // TODO: should use calcualtePathMetaData here, but we first need to do some more stuff before this can be done... calcualtePathMetaData probably needs to receive a full path instead of a operationFolderPath + relativePath because it can be used outside of operations as well...\n              const metaData = undefined;\n\n              const folderResult: TextJson = {\n                path: thisFolderPath,\n                metaData,\n                isFolder: true,\n              };\n\n              results.push(folderResult);\n            }\n          }\n        }\n\n        return results;\n      }\n\n      return null;\n    }\n  );\n\n  const allMatches = (await Promise.all(textJsonPromises))\n    .filter(notEmpty)\n    .flat();\n\n  return allMatches;\n}",
  "description": "Explores your files with many possibilities.\n\nNB: this function only searches one basePath, while explore can do multiple\n\nTODO: since this not only finds files but also explores them, naming should be exploreFilesRecursively, probably.\n\nTODO: TextJson[] is a bit weird name for the resulting type interface...",
  "id": "zqzqulfxdmmpiqfasxwmowjr"
}