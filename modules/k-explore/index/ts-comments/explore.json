[{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"these filetypes should never be opened with explore. They should be processed and either indexed or converted. This creates a md or json with the proper metadata, which, in turn, can be explored.","rawStatement":"export type DropboxExtension =\n  | \"doc\"\n  | \"docx\"\n  | \"csv\"\n  | \"xls\"\n  | \"xlsx\"\n  | \"epub\"\n  | \"pdf\";","parameters":{},"types":[],"firstLine":27,"lastLine":29},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"type checker for a string to be an extension that can be searched for","rawStatement":"const isSearchContentExtension = (\n  extension: string\n): extension is SearchableExtension => {\n  return allowedSearchContentExtensions\n    .map((x) => x as string)\n    .includes(extension);\n};","parameters":{},"types":[],"firstLine":63,"lastLine":65},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"returns the file type or null if it's unknown","rawStatement":"export const determineFileType = (filePath: string) => {\n  const extension = path.parse(filePath).ext.substring(1);\n  if (!isSearchContentExtension(extension)) return null;\n  const index = fileTypes.findIndex((fileType) =>\n    extensions[fileType].includes(extension)\n  );\n  const fileType = fileTypes[index];\n  return fileType;\n};","parameters":{},"types":[],"firstLine":73,"lastLine":75},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"","rawStatement":"const getOutline = (filePath: string) => {\n  console.log(\"outline is currently just filename\");\n  return filePath.split(\"/\").pop();\n};","parameters":{},"types":[],"firstLine":86,"lastLine":88},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"gets needed contents of file path, based on the extension\n\nreturns a markdownparse if it's markdown, a json parse for json, or a file content string for anything else","rawStatement":"const getContents = async (filePath: string) => {\n  // console.log(\"Get contents\", filePath);\n  const extension = getExtension(filePath);\n  if (!isSearchContentExtension(extension)) {\n    return;\n  }\n\n  if (extension === \"json\") {\n    return readJsonFile<any>(filePath);\n  } else if (markdownExtensions.includes(extension)) {\n    const contents = await fs.readFile(filePath, \"utf8\");\n    const markdownParse = mdToJsonParse(contents);\n    return markdownParse;\n  } else {\n    const fileString = fs.readFile(filePath, \"utf8\");\n    return fileString;\n  }\n};","parameters":{},"types":[],"firstLine":110,"lastLine":114},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"this is the safe and friendly version of findFilesRecursively: it","rawStatement":"export const explore = async ({\n  basePath,\n  searchLevel = \"fileName\",\n  debug,\n  ...other\n}: SearchConfig): Promise<TextJson[]> => {\n  /** accessability depends on whether we need to be able to read the file, or just see it */\n  const canAccess = async (p: string) =>\n    await (searchLevel === \"outline\" || searchLevel === \"full\"\n      ? canRead\n      : canSee)(p);\n\n  /** basepaths becomes an array of only the basepaths that we can access */\n  const accessibleBasePaths = makeArray(basePath || getProjectRoot())\n    .filter(fs.existsSync)\n    .filter(canAccess);\n\n  if (debug) console.log(`finding files in ${accessibleBasePaths.join(\",\")}`);\n\n  const textJsonPromises = accessibleBasePaths.map(async (p) =>\n    findFilesRecursively({ basePath: p, searchLevel, debug, ...other })\n  );\n\n  const textJsons = (await Promise.all(textJsonPromises)).flat();\n\n  return textJsons;\n};","parameters":{},"types":[],"firstLine":204,"lastLine":206},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"Explores your files with many possibilities.\n\nNB: this function only searches one basePath, while explore can do multiple\n\nTODO: since this not only finds files but also explores them, naming should be exploreFilesRecursively, probably.\n\nTODO: TextJson[] is a bit weird name for the resulting type interface...","rawStatement":"export const findFilesRecursively = async (\n  config: Omit<SearchConfig, \"basePath\"> & {\n    // this is the only difference compared to the other searchconfig\n    basePath: string;\n  }\n): Promise<TextJson[]> => {\n  const {\n    basePath,\n    ignore,\n    searchLevel,\n    extension,\n    subExtension,\n    search,\n    //booleans:\n    includeFoldersWithResults,\n    doNotExploreMatch,\n    doNotExploreChildFolders,\n    debug,\n    exact,\n    includeStats,\n    includeMetaData,\n    cancelRecursionOn,\n  } = config;\n  // NB: we know we only use this function like this\n  const subExtensions = makeArray(subExtension);\n  const extensions = makeArray(extension);\n  const searches = makeArray(search);\n  const ignores = makeArray(ignore);\n\n  const contents = await fs.readdir(basePath, {\n    withFileTypes: true,\n    encoding: \"utf8\",\n  });\n\n  const pathArray = contents.map((x) => path.join(basePath, x.name));\n\n  // if contents should not be explored, return an empty array\n  if (cancelRecursionOn?.(pathArray)) {\n    return includeFoldersWithResults\n      ? [{ path: basePath, isCancelRecursionResult: true }]\n      : [];\n  }\n\n  if (debug) console.log(`contents contains ${contents.length} files/folders`);\n\n  const textJsonPromises: Promise<TextJson[] | null>[] = contents.map(\n    async (dirent) => {\n      // don't check files if search level is folder\n      if (searchLevel === \"folder\" && dirent.isFile()) {\n        return null;\n      }\n\n      //if dir/file name should be ignored, skip it\n      if (ignores.includes(dirent.name)) {\n        if (debug) console.log(\"Ignoring\", dirent.name);\n        return null;\n      }\n\n      // if we want specific sub-extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        subExtensions &&\n        subExtensions.length > 0 &&\n        !subExtensions.find((ext) => getSubExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(\n            `ignoring ${dirent.name} because of subextension mismatch`\n          );\n        return null;\n      }\n\n      // if we want specific extensions and this file isn't one of them, return\n      if (\n        dirent.isFile() &&\n        extensions &&\n        extensions.length > 0 &&\n        !extensions.find((ext) => getExtension(dirent.name) === ext)\n      ) {\n        if (debug)\n          console.log(`ignoring ${dirent.name} because of extension mismatch`);\n        return null;\n      }\n\n      const filePath: string = path.join(basePath, dirent.name);\n\n      // if it's a file, we don't go into recursion.\n      if (dirent.isFile()) {\n        const ext = getExtension(dirent.name) || \"\";\n\n        //getting extension\n\n        const isJson = jsonExtensions.includes(ext);\n        const isTypescript = typescriptExtensions.includes(ext);\n        const isMarkdown = markdownExtensions.includes(ext);\n\n        //NB: be careful when ever changing this logic!\n        // It should never get contents when it doesn't need to,\n        // because this is a very heavy operation.\n\n        const searchContender =\n          searchLevel === \"folder\"\n            ? dirent.name\n            : searchLevel === \"fileName\"\n            ? dirent.name\n            : searchLevel === \"filePath\" || !isSearchContentExtension(ext)\n            ? filePath //withoutExtension? dirent.name or filePath??? we also want to match folder names before it, right?\n            : //TODO: is getOutLine() evaluated if it's not an outline? it also seems the default, which I don't like. Test this, it's an important aspect of exploring efficiently.\n            searchLevel === \"outline\"\n            ? getOutline(filePath)!\n            : searchLevel === \"full\"\n            ? await getContents(filePath)\n            : \"SHOULD_NEVER_HAPPEN\";\n\n        if (debug) console.log(`searchContender: ${searchContender}`);\n        const match = isMatch({ exact, searchContender, searches });\n\n        const json: any | undefined =\n          isJson && searchLevel === \"full\" ? getContents(filePath) : undefined;\n\n        const markdownJson: MarkdownParse | undefined =\n          isMarkdown && searchLevel === \"full\"\n            ? // TODO: get markdown parse here\n              await getContents(filePath)\n            : undefined;\n\n        // NB: TODO: we don't do typescript json yet\n        // TODO: I think double special comments (like the above) on a single line isn't indexed yet, is it?\n        const typescriptJson: undefined = isTypescript ? undefined : undefined;\n\n        const stats = includeStats ? await fs.stat(filePath) : undefined;\n\n        if (debug) console.log(`${dirent.name}? match ${match}`);\n        //match found...\n        const matchOrNot: TextJson[] | null = match\n          ? [\n              {\n                path: filePath,\n                json,\n                markdownJson,\n                typescriptJson,\n                stats,\n              },\n            ]\n          : null;\n        return matchOrNot;\n      }\n\n      // ^ these were all the base cases ^. Now the recursion.\n\n      if (dirent.isDirectory() && !doNotExploreChildFolders) {\n        let results = [];\n        let shouldRecurse = true;\n        if (searchLevel === \"folder\") {\n          const searchContender = dirent.name;\n          const match = isMatch({ searchContender, exact, searches });\n\n          if (match) {\n            results.push({\n              path: filePath,\n            });\n            shouldRecurse = !doNotExploreMatch;\n          }\n        }\n\n        /**\n       don't dive into folder if:\n      - we're looking for folders \n      - the folder has matched \n      - we don't explore matches\n      */\n        if (shouldRecurse) {\n          const thisFolderPath = path.join(basePath, dirent.name);\n          const thisFolderResults = await findFilesRecursively({\n            basePath: thisFolderPath,\n            extension,\n            search,\n            searchLevel,\n            subExtension,\n            ignore,\n            debug,\n            exact,\n            // NB: I think we just need to fill in everything in the recursion, right?\n            cancelRecursionOn,\n            includeFoldersWithResults,\n            includeMetaData,\n            includeStats,\n            doNotExploreChildFolders,\n            doNotExploreMatch,\n          });\n\n          if (thisFolderResults.length > 0) {\n            results = results.concat(thisFolderResults);\n\n            if (includeFoldersWithResults) {\n              // NB: we can't show any stats because this fs.stats function only works on files. We could sum all stats recursively\n\n              // TODO: should use calcualtePathMetaData here, but we first need to do some more stuff before this can be done... calcualtePathMetaData probably needs to receive a full path instead of a operationFolderPath + relativePath because it can be used outside of operations as well...\n              const metaData = undefined;\n\n              const folderResult: TextJson = {\n                path: thisFolderPath,\n                metaData,\n              };\n\n              results.push(folderResult);\n            }\n          }\n        }\n\n        return results;\n      }\n\n      return null;\n    }\n  );\n\n  const allMatches = (await Promise.all(textJsonPromises))\n    .filter(notEmpty)\n    .flat();\n\n  return allMatches;\n};","parameters":{},"types":["todo","nb"],"firstLine":235,"lastLine":243},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"Finds all package.json's everywhere. also in /tools, but this is to be expected.\n\nTODO: `stopRecursionAfterMatch` never worked, so I just removed it... the behavior now is that it also explores folders that are in a folder with a `package.json`, unless that foldername is ignored. For now it's fine, but this could easily create an ineficiency if there's a lot of data in an operation or something...\n\nTODO: We should be careful with ignoring all these folders... what if we use those folders outside of operations? This could have unexpected behavior. We either need to lint for these foldernames not to be used, or we need to make sure to only ignore it if we encounter a package.json","rawStatement":"export const findAllPackages = (config?: {\n  basePath: string | string[] | undefined;\n}) => {\n  return explore({\n    basePath: config?.basePath || getPathsWithOperations(),\n    search: \"package.json\",\n    exact: true,\n    extension: \"json\",\n    searchLevel: \"fileName\",\n    ignore: generatedFolders.concat([\"src\", \"assets\", \"data\"]),\n  });\n};","parameters":{},"types":["todo"],"firstLine":470,"lastLine":476},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"find all active git folders (folders having `.git`)","rawStatement":"export const exploreGitRepoFolders = async (config: BaseConfig) => {\n  return (await findAllDotGitFolders(config))\n    .map((textJson) => textJson.path)\n    .map((p) => path.resolve(p, \"..\"));\n};","parameters":{},"types":[],"firstLine":501,"lastLine":503},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"find all active operations (folders having `package.json` but also `tsconfig.json`)","rawStatement":"export const exploreOperationFolders = async (config: BaseConfig) => {\n  const folders = (await findAllPackages({ basePath: config?.basePath }))\n    .map((textJson) => textJson.path)\n    .map((p) => getFolder(p))\n    .filter((p) => fs.existsSync(path.join(p, \"tsconfig.json\")));\n\n  return folders;\n};","parameters":{},"types":[],"firstLine":510,"lastLine":512},{"id":"sfntoPXjeSIQdpQn","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/k-explore/src/explore.ts","srcFileId":"/explore","operationFolderName":"k-explore","relativeFilePathFromSrc":"/explore.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/k-explore","operationName":"k-explore","comment":"DEPRECATED: not sure if we still need it, look up usecases, can prob be replaced now","rawStatement":"export const exploreMultiple = async (searchConfigs: SearchConfig[]) => {\n  const textJsonPromises = searchConfigs.map(async (config) => {\n    return explore(config);\n  });\n\n  return (await Promise.all(textJsonPromises)).flat();\n};","parameters":{},"types":[],"firstLine":618,"lastLine":620}]