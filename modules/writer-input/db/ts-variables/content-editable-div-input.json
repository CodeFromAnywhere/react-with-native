{
  "createdAt": 1667588116704,
  "updatedAt": 1667588116704,
  "deletedAt": 0,
  "createdFirstAt": 1667588116704,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "ContentEditableDivInput",
  "slug": "content-editable-div-input",
  "operationRelativeTypescriptFilePath": "src/editors/ContentEditableDivInput.tsx",
  "type": {
    "rawType": "<T extends unknown>(props: { value: string; onChange: (newValue: string) => void; markdownParseRenderConfig?: import(\"/Users/king/King/operations/tools/interfaces/vui/vui-elements/markdown/build/esm/types\").MarkdownParseRenderConfig | undefined; subwordConfig: import(\"/Users/king/King/operations/tools/writer/writer-types/build/types\").SubwordConfig; subtextConfig: import(\"/Users/king/King/operations/tools/writer/writer-types/build/types\").SubtextConfig; parseTextContentToHtmlString: import(\"/Users/king/King/operations/tools/writer/writer-input/src/editors/SmartContentEditableDivInput\").ParseTextContentToHtmlString; divProps: Omit<any, \"contentEditable\" | \"onChange\" | \"onInput\" | \"value\">; }) => JSX.Element",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "<T extends any>(props: {\n  /**\n   * the current raw content of the input\n   */\n  value: string;\n  /**\n   * save your state with this function\n   */\n  onChange: (newValue: string) => void;\n\n  /**\n   * NB: not needed for non-markdown stuff\n   */\n  markdownParseRenderConfig?: MarkdownParseRenderConfig;\n  subwordConfig: SubwordConfig;\n  subtextConfig: SubtextConfig;\n  /**\n   * Your function to parse the raw text into styled text (HTML)\n   *\n   * NB: you can't use react in here, this function needs to return a string!\n   */\n  parseTextContentToHtmlString: ParseTextContentToHtmlString;\n\n  /**\n   * Extra props you want to pass to the main div\n   */\n  divProps: Omit<\n    FinalDivType<T>,\n    \"value\" | \"onChange\" | \"onInput\" | \"contentEditable\"\n  >;\n}) => {\n  const {\n    value,\n    onChange,\n    divProps,\n    parseTextContentToHtmlString,\n    markdownParseRenderConfig,\n    subtextConfig,\n    subwordConfig,\n  } = props;\n\n  useEffect(() => {\n    // NB: `value` changes whenever we call onChange, if the component is used as intended\n    updateEditor(value);\n\n    /**\n     * Every time the value changes, we need to create all click listeners...\n     */\n\n    /**\n     * For every meta clickable, add an event listener for when we click on it.\n     *\n     * If that happens, check if the meta key is enabled.\n     *\n     * If that's true, use the data-href property and go to that URL\n     */\n    const listeners = Array.from(\n      document.getElementsByClassName(metaClickableClassName)\n    )\n      .map((element) => {\n        if (element.tagName !== \"DIV\") return;\n\n        const listener = (clickEvent: MouseEvent) => {\n          if (clickEvent.metaKey) {\n            console.log(\n              \"clicked an image elemen with the metakey enabled... let's go?\",\n              {\n                datasetHref: (element as HTMLDivElement).dataset.href,\n                dataHref: (element as any)[\"data-href\"],\n              }\n            );\n          }\n        };\n        (element as HTMLDivElement).addEventListener(\"click\", listener);\n\n        return { divElement: element as HTMLDivElement, listener };\n      })\n      .filter(notEmpty);\n\n    return () => {\n      /**\n       * Clean up\n       */\n      listeners.map((item) => {\n        const { divElement, listener } = item;\n\n        divElement.removeEventListener(\"click\", listener);\n      });\n    };\n  }, [value]);\n\n  const editor = useRef<HTMLDivElement>(null);\n\n  const getEditorContent = () => {\n    const textSegments = getTextSegments(editor.current);\n\n    const textContent = textSegments.map(({ text }) => text).join(\"\");\n\n    // console.log(\"OK\", { textSegments, textContent });\n    return { textSegments, textContent };\n  };\n\n  /**\n   * Executed every time input changes by user input.\n   *\n   * Ensures the innerHTML is updated for the editor, while the selection stays the same\n   *\n   * NB: to also allow for non-user-based changes, we need to restoreSelection in a different way, probably.\n   */\n  function updateEditor(value: string) {\n    // 1) get selection, segments and the full content (without styling)\n    const selection = window.getSelection();\n    // NB: this never happens I assume\n    if (!selection) return;\n    const { textSegments } = getEditorContent();\n\n    // 2) Use the `textSegments` to find `anchorIndex` and `focusIndex`\n    let anchorIndex: number | null = null;\n    let focusIndex: number | null = null;\n    let currentIndex = 0;\n    textSegments.forEach(({ text, node }) => {\n      if (node.isEqualNode(selection.anchorNode)) {\n        anchorIndex = currentIndex + selection.anchorOffset;\n      }\n      if (node.isEqualNode(selection.focusNode)) {\n        focusIndex = currentIndex + selection.focusOffset;\n      }\n      currentIndex += text.length;\n    });\n\n    if (!editor.current) return;\n\n    const newInnerHTML = parseTextContentToHtmlString(\n      value,\n      \"markdown\",\n      subtextConfig,\n      subwordConfig,\n      markdownParseRenderConfig\n    );\n\n    // console.log({ value, newInnerHTML });\n    // 3) Recalculate the inner HTML of the editor based on the raw text string\n    editor.current.innerHTML = newInnerHTML;\n\n    // NB: not sure if this is really needed...? I guess so\n    ReactTooltip.rebuild();\n\n    if (anchorIndex === null || focusIndex === null) return;\n    // 4) restore selection as index of the new string\n    restoreSelection(anchorIndex, focusIndex);\n  }\n\n  /**\n   * Restores selection after updating inner HTML\n   */\n  function restoreSelection(\n    absoluteAnchorIndex: number,\n    absoluteFocusIndex: number\n  ) {\n    const selection = window.getSelection();\n    if (selection === null) return;\n\n    const textSegments = getTextSegments(editor.current);\n    let anchorNode: ChildNode | null = editor.current;\n\n    if (anchorNode === null) return;\n\n    let anchorIndex = 0;\n    let focusNode: ChildNode | null = editor.current;\n\n    if (focusNode === null) return;\n\n    let focusIndex = 0;\n    let currentIndex = 0;\n\n    textSegments.forEach(({ text, node }) => {\n      const startIndexOfNode = currentIndex;\n      const endIndexOfNode = startIndexOfNode + text.length;\n      if (\n        startIndexOfNode <= absoluteAnchorIndex &&\n        absoluteAnchorIndex <= endIndexOfNode\n      ) {\n        anchorNode = node;\n        anchorIndex = absoluteAnchorIndex - startIndexOfNode;\n      }\n      if (\n        startIndexOfNode <= absoluteFocusIndex &&\n        absoluteFocusIndex <= endIndexOfNode\n      ) {\n        focusNode = node;\n        focusIndex = absoluteFocusIndex - startIndexOfNode;\n      }\n\n      currentIndex += text.length;\n    });\n\n    selection.setBaseAndExtent(anchorNode, anchorIndex, focusNode, focusIndex);\n  }\n\n  /**\n   * onInput doesn't always register enters\n   *\n   * onKeyPress is already registered before the content is inside, so that also causes problems.\n   *\n   * onKeyUp seems to be the only event that really works well\n   *\n   * (Only tested in Safari!)\n   */\n  const onKeyUp = () => {\n    // console.log({ innerText: editor.current?.innerText });\n\n    const { textContent } = getEditorContent();\n\n    // NB: editor.current?.innerText would be nice, but it doesn't work because it adds an extra newline...\n    // Besides that, it also is unable to strip certain HTML\n    onChange(textContent);\n  };\n\n  return (\n    <Div>\n      <Div\n        ref={editor}\n        onKeyUp={onKeyUp}\n        contentEditable\n        spellCheck={false}\n        {...divProps}\n      />\n    </Div>\n  );\n}",
  "description": "Div that is `contentEditable` by default and has possibilities for color/style highlighting, autocomplete, subtexts and tooltips",
  "id": "yduygyixqyztglvqyijrhwip"
}