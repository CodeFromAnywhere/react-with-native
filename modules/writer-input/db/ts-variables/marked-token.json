{
  "createdAt": 1667588120727,
  "updatedAt": 1667588120727,
  "deletedAt": 0,
  "createdFirstAt": 1667588120727,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "MarkedToken",
  "slug": "marked-token",
  "operationRelativeTypescriptFilePath": "src/editors/MarkedToken.tsx",
  "type": {
    "rawType": "(props: { item: import(\"/Users/king/King/operations/node_modules/@types/marked/index\").marked.Token; subtextConfig: import(\"/Users/king/King/operations/tools/writer/writer-types/build/types\").SubtextConfig; subwordConfig: import(\"/Users/king/King/operations/tools/writer/writer-types/build/types\").SubwordConfig; markdownFileConfig: import(\"/Users/king/King/operations/tools/interfaces/vui/vui-elements/markdown/build/esm/types\").MarkdownParseRenderConfig; testModeEnabled?: boolean | undefined; }) => JSX.Element",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "(props: {\n  item: marked.Token;\n  subtextConfig: SubtextConfig;\n  subwordConfig: SubwordConfig;\n  markdownFileConfig: MarkdownParseRenderConfig;\n  /**\n   * If enabled, all content will be tested in realtime\n   */\n  testModeEnabled?: boolean;\n}): JSX.Element => {\n  const {\n    item,\n    markdownFileConfig,\n    subtextConfig,\n    subwordConfig,\n    testModeEnabled,\n  } = props;\n\n  if (item.type === \"heading\") {\n    const fontSize = depthFontSizes[item.depth as 1 | 2 | 3 | 4 | 5 | 6 | 7];\n\n    const headingContent =\n      item.tokens && item.tokens.length > 1 ? (\n        `${`#`.repeat(item.depth)} ${item.tokens.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}`\n      ) : (\n        <SpannedSentence\n          sentence={item.raw}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      );\n\n    return (\n      <>\n        <p>\n          <strong style={{ color: \"blue\", fontSize }}>{headingContent}</strong>\n        </p>\n        {getSubtext(item.text, subtextConfig)}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"space\") {\n    // 1 newline splits into two parts here, 5 newlines are 6 parts, so if we omit the first one, we get an array with the length of the amount of newlines\n    const newlines = item.raw.split(\"\\n\").slice(1);\n\n    return (\n      <>\n        {newlines.map(() => (\n          <br />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"blockquote\") {\n    // > ....\n    return (\n      <p>\n        <strong style={{ color: \"blue\" }}>&gt;</strong>\n        <SpannedSentence\n          sentence={item.text}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </p>\n    );\n  }\n\n  if (item.type === \"paragraph\") {\n    // Paragraph always has tokens?\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedParagraph, item);\n    }\n\n    return (\n      <MarkedParagraph\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"text\") {\n    if (testModeEnabled) {\n      testContentEditableRenderComponent(MarkedText, item);\n    }\n    return (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        markdownFileConfig={markdownFileConfig}\n        subtextConfig={subtextConfig}\n      />\n    );\n  }\n\n  if (item.type === \"list\") {\n    return (\n      <>\n        {item.items.map((token) => (\n          <MarkedToken\n            item={token}\n            subtextConfig={subtextConfig}\n            subwordConfig={subwordConfig}\n            markdownFileConfig={markdownFileConfig}\n            testModeEnabled={testModeEnabled}\n          />\n        ))}\n      </>\n    );\n  }\n\n  if (item.type === \"list_item\") {\n    const beforeText = item.raw.split(item.text)[0];\n\n    const text = (\n      <MarkedText\n        markedToken={item}\n        subwordConfig={subwordConfig}\n        subtextConfig={subtextConfig}\n        markdownFileConfig={markdownFileConfig}\n      />\n    );\n\n    return (\n      <>\n        <b style={{ color: \"blue\" }}>{beforeText}</b> {text}\n        <br />\n      </>\n    );\n  }\n\n  if (item.type === \"escape\") {\n    return (\n      <b style={{ color: \"red\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"strong\") {\n    return (\n      <b style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </b>\n    );\n  }\n\n  if (item.type === \"em\") {\n    return (\n      <i style={{ color: \"blue\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </i>\n    );\n  }\n\n  if (item.type === \"image\") {\n    const realSrc = getRealSrc(item.href, markdownFileConfig);\n    return (\n      <div\n        data-href={realSrc}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"<img src='${realSrc}' width=200 /><br>'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"link\") {\n    return (\n      <div\n        data-href={item.href}\n        className={metaClickableClassName}\n        data-html=\"true\"\n        data-tip=\"'Cmd+Click' to open\"\n      >\n        {item.raw}\n      </div>\n    );\n  }\n\n  if (item.type === \"html\") {\n    return (\n      <span style={{ color: \"green\" }}>\n        {item.raw\n          .replaceAll(\"<\", \"&lt;\")\n          .replaceAll(\">\", \"&gt;\")\n          .replaceAll(\"\\n\", \"<br />\")}\n      </span>\n    );\n  }\n\n  if (item.type === \"codespan\") {\n    // Need to add tooltip here for augmented words\n\n    const trimmedWord = trimAround(item.raw, 1);\n\n    return (\n      <span style={{ color: \"orange\" }}>\n        \\`\n        {trimmedWord.split(\" \").map((word) => {\n          const augmentedWord = markdownFileConfig.augmentedWordObject?.[word];\n\n          return (\n            <span\n              data-tip={\n                augmentedWord && augmentedWord.spoiler\n                  ? augmentedWord.spoiler\n                  : undefined\n              }\n            >\n              {word}\n            </span>\n          );\n        })}\n        \\`\n      </span>\n    );\n  }\n\n  if (item.type === \"code\") {\n    return (\n      <span style={{ color: \"orange\" }}>\n        <MarkedText\n          markedToken={item}\n          subwordConfig={subwordConfig}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n        />\n      </span>\n    );\n  }\n\n  if (item.type === \"table\") {\n    return (\n      <span style={{ color: \"pink\" }}>\n        <MarkedText\n          markedToken={item}\n          markdownFileConfig={markdownFileConfig}\n          subtextConfig={subtextConfig}\n          subwordConfig={subwordConfig}\n        />\n      </span>\n    );\n  }\n\n  console.log(`unhandled: ${item.type}`, item);\n  return <></>;\n}",
  "description": "Function that can be used to iterate over the marked parse and style every token, recursively\n\nNB: this returns a regular react component, and should, for setting it as InnerHTML, be parsed with the `ReactDOMServer`",
  "id": "ahokqkgkszhpaktawptlyuij"
}