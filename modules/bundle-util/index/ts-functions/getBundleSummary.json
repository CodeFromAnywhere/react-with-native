[{"id":"mGisxxGOALqVoyss","commentsInside":[],"rawText":" (bundleConfig: BundleConfig): BundleSummary => {\n  const bundlesPath = getRootPath(\"bundles\");\n  const foldersFromRepo = bundlesPath\n    ? bundleConfig.foldersFromRepo?.map((x) =>\n        path.join(bundlesPath, kebabCase(bundleConfig.name), x)\n      )\n    : undefined;\n\n  // const filesAndFoldersToInclude = [\n  //   // ...(foldersFromRepo || []),\n  //   bundleConfig.readmeRelativeFilePath,\n  //   bundleConfig.docsRelativeFolderPath,\n  // ].filter(notEmpty);\n\n  const appNames = bundleConfig.bundles\n    .map((x) => {\n      const frontendOperationNames = makeArray(\n        x.appShellOperationNames,\n        x.serverOperationName\n      );\n\n      return frontendOperationNames;\n    })\n    .flat()\n    .filter(onlyUnique2());\n\n  const uiOperationNames = makeArray(\n    bundleConfig.bundles.map((x) => x.uiOperationName).filter(notEmpty)\n  );\n\n  const bundlePublicOperationNames = bundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"public\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n  const bundlePrivateOperationNames = bundleConfig.bundles\n    .map(\n      (x) =>\n        x.operations\n          ?.filter((x) => x.privacy === \"private\")\n          .map((x) => x.operationName) || []\n    )\n    .flat();\n\n  const packageNames = bundleConfig.dependencies\n    .filter((x) => x.privacy === \"public\")\n    .map((x) => x.operationName)\n    .concat(uiOperationNames)\n    .concat(bundlePublicOperationNames)\n    .filter(onlyUnique2());\n\n  const moduleNames = bundleConfig.dependencies\n    .filter((x) => x.privacy === \"private\")\n    .map((x) => x.operationName)\n    .concat(bundlePrivateOperationNames)\n    .filter(onlyUnique2());\n\n  const summary: BundleSummary = {\n    // filesAndFoldersToInclude,\n    packageNames,\n    moduleNames,\n    appNames,\n  };\n\n  return summary;\n}","name":"getBundleSummary","slug":"get-bundle-summary","parameters":[{"name":"bundleConfig","schema":{"$ref":"#/definitions/BundleConfig"},"simplifiedSchema":{"properties":[{"name":"createdAt","required":true,"schema":{"description":"Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()","type":"number"}},{"name":"updatedAt","required":true,"schema":{"description":"Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()","type":"number"}},{"name":"deletedAt","required":true,"schema":{"description":"Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()","type":"number"}},{"name":"createdFirstAt","required":true,"schema":{"description":"Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()","type":"number"}},{"name":"id","required":true,"schema":{"description":"unique id used for compatibility purposes","type":"string"}},{"name":"slug","required":true,"schema":{"description":"use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.","type":"string"}},{"name":"name","required":true,"schema":{"description":"Human readable name of the monorepo (A kebab-case version of this will be used as root foldername)","type":"string"}},{"name":"language","required":true,"schema":{"description":"all currently supported languages","enum":["en","nl","np","pt","de","fr","es","it","no","sw","da","vn","in","vl","af"],"type":"string"}},{"name":"bundles","required":true,"schema":{"items":[{"schema":{"description":"This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately","properties":[{"name":"operations","required":false,"schema":{"description":"any operation names that are not necesarily dependencies of the named front-back bundle but still need to be available.","items":[{"schema":{"properties":[{"name":"operationName","required":true,"schema":{"type":"string"}},{"name":"privacy","required":true,"schema":{"description":"if public, everything will be kept\n\nif private, src and todo will be removed from bundle, unless it's a ui-es6 operation, because src is needed then. In that case, only \"todo\" will be deleted.","enum":["public","private"],"type":"string"}}],"type":"object"},"name":"OperationPrivacy"}],"type":"array"}},{"name":"uiOperationName","required":false,"schema":{"description":"(optional) main shared ui package of the frontend","type":"string"}},{"name":"appShellOperationNames","required":false,"schema":{"description":"which app shell(s) or app operations are there for the frontend?","items":[{"schema":{"type":"string"},"name":null}],"type":"array"}},{"name":"serverOperationName","required":false,"schema":{"description":"operation name for server, if this UI is connected to one","type":"string"}},{"name":"envOperationName","required":false,"schema":{"description":"if the server is to be deployed, specify the server-env package that exposes the server environment variables (JSON) to the ui\n\nBy default, uses \"server-env\" operation, which simply exposes a configuration env.json file. the generation of the bundle will set the \"remoteServer\" key in this env.json to the \"productionApiUrl\" so the deployed version can reach the api","type":"string"}},{"name":"productionApiUrl","required":false,"schema":{"description":"if there is one, it should be specified here (without trailing slash)","type":"string"}},{"name":"endpointsAuthToken","required":false,"schema":{"description":"if this is provided, all endpoints require this auth token to be provided, or the endpoints do not work\n\nif you wish to have a more extensive authentication method for your endpoints, make sure to create your own auth layer","type":"string"}}],"type":"object"},"name":"FrontBackBundle"}],"type":"array"}},{"name":"dependencies","required":true,"schema":{"description":"Generated, private by default. If they're already here, uses private/public setting as given.\n\nWhen generating, removes the ones that are not dependencies (of dependencies) of your standalone apps","items":[{"schema":{"properties":[{"name":"operationName","required":true,"schema":{"type":"string"}},{"name":"privacy","required":true,"schema":{"description":"if public, everything will be kept\n\nif private, src and todo will be removed from bundle, unless it's a ui-es6 operation, because src is needed then. In that case, only \"todo\" will be deleted.","enum":["public","private"],"type":"string"}}],"type":"object"},"name":"OperationPrivacy"}],"type":"array"}},{"name":"docsRelativeFolderPath","required":false,"schema":{"description":"later this could be known by the frontend so it will render a ui to select a folder\n\nWe need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.","type":"string"}},{"name":"readmeRelativeFilePath","required":false,"schema":{"type":"string"}},{"name":"foldersFromRepo","required":false,"schema":{"description":"if given, it will fetch these folders from the repo and paste them in the bundle whenever the bundle is generated\n\ncan be handy if you're working with someone else...","items":[{"schema":{"type":"string"},"name":null}],"type":"array"}},{"name":"informationStrategy","required":false,"schema":{"description":"push (default): take needed information from project and push to bundle (removing the existing info)\n\npullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n\npullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n\nNB: Later we may want to define this setting on a per-model basis!","enum":["push","pullReplace","pullMerge"],"type":"string"}},{"name":"gitRepoUrl","required":false,"schema":{"type":"string"}},{"name":"branchName","required":false,"schema":{"description":"specify the branch to use of your git repo (defaults to \"main\")","type":"string"}}],"type":"object"},"required":true}],"description":"Summarizes a bundle config so it can be used easily in things like explore project","returnType":{"rawType":"import(\"/Users/king/King/tools/deployment/bundling/bundle-util/src/getBundleSummary\").BundleSummary","typeDefinition":{"type":"object","properties":{"packageNames":{"type":"array","items":{"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]}},"moduleNames":{"type":"array","items":{"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]}},"appNames":{"type":"array","items":{"type":"string","allOf":[{"transform":["trim"]},{"minLength":1}]}}},"required":["packageNames","moduleNames","appNames"],"optional":false},"typeCoverage":0,"isArray":false,"isEnum":false,"isObject":true,"isPrimitive":false,"isEnumLiteral":false,"simplifiedSchema":{"properties":[{"name":"packageNames","required":true,"schema":{"items":[{"schema":{"type":"string"},"name":null}],"type":"array"}},{"name":"moduleNames","required":true,"schema":{"items":[{"schema":{"type":"string"},"name":null}],"type":"array"}},{"name":"appNames","required":true,"schema":{"items":[{"schema":{"type":"string"},"name":null}],"type":"array"}}],"type":"object"}},"maxIndentationDepth":5,"relativePathFromProjectRoot":"/tools/deployment/bundling/bundle-util/src/getBundleSummary.ts","srcFileId":"/getBundleSummary","operationFolderName":"bundle-util","relativeFilePathFromSrc":"/getBundleSummary.ts","relativeOperationBasePathFromProjectRoot":"/tools/deployment/bundling/bundle-util","operationName":"bundle-util","size":{"characters":1922,"lines":69,"bytes":1922,"bytesPerCharacter":1,"charactersPerfLine":27.855072463768117,"linesPerFile":69,"numberOfFiles":1}}]