{
  "fileName": "functions",
  "raw": "# bundleFolderWithMarkdown\n\nfinds all md files in a folder and creates a single MarkdownParse\n\nhandy for creating a single documentation file or other things that have to include multiple markdown files in a structured way\n\nNB: it recursively structures the files and folders with headings\n\n\n\n## Parameters (2)\n\n### Parameter 1: absoluteFolderPath: string\n\n\n\n\n\n\n\n### Parameter 2: fileName (optional): string\n\n\n\n> filename to include in the final MarkdownParse\n\n\n\n# bundleToBookMarkdown\n\nInput: BundleConfig (one or more folder(s), readme, operations with a docs folder)\n\nOutput should be all md files concatenated in the right order with the right titles\n\n\n\n## Parameters (1)\n\n### Parameter 1: config: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| bundleConfig  | object | --- dbStorageMethod: jsonSingle<br />--- |\n| title (optional) | string |  |\n| coverImagePath (optional) | string |  |\n| isModulesIncluded (optional) | boolean |  |\n| manualProjectRoot (optional) | string |  |\n\n\n# bundleToMarkdown\n\ncreates a summary for a whole bundle\n\nNB: Related to `bundleToBookMd`\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  bundleConfigId,  includeModules,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| bundleConfigId  | string |  |\n| includeModules (optional) | boolean | if true, also includes the private modules |\n\n\n# deployToVercel\n\nNB: Obviously, this is not the right place for this function, but none of these functions are properly located yet...\n\nshould deploy any bundle or next project folder project to Vercel by first creating and pushing it into git, and then creating it in vercel through their api\n\nshould return an url where the project will be served and the estimated time when it will be live\n\n\n\n# emailMarkdownParse\n\nshould email a markdown parse to some email (or multiple)\n\n\n\n# generateStaticSite\n\ngenerates static site from a markdown file, with a menu on the right by default\n\nuses next.js\n\nbecause it is static, the markdown can be in the frontend assets and there is no need for a backend\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  projectRelativeMdFilePath,  singlePage,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| singlePage (optional) | boolean |  |\n| projectRelativeMdFilePath (optional) | string |  |\n\n\n# getOutline\n\nlow-level function that gets the outline for MarkdownParse\n\nNB: with books usually the pages are referred in the outline. Since that depends on the font size and dimensions, this cannot be done straight from the markdown parse. Eventually we probably need to check the made pdf for its content, maybe there is even a pdf feature that creates an outline for you. There must be more people having this problem.\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: markdownParse: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| fileName (optional) | string | if available, this can be the filename of the markdown in this markdown-parse. Can be used for things like merging |\n| createdAt (optional) | number |  |\n| openedAt (optional) | number |  |\n| updatedAt (optional) | number |  |\n| deletedAt (optional) | number |  |\n| createdFirstAt (optional) | number |  |\n| content (optional) | array | structured content based on h1, h2, h3, etc (paragraphs, recursive) |\n| raw  | string | raw markdown without frontmatter |\n\n\n# getTitlesRecursively\n\nhelper function to get a nested array of the titles and its subtitles\n\n\n\n## Parameters (1)\n\n### Parameter 1: chunk: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| content (optional) | string |  |\n| title (optional) | string | NB: title can also be an empty string (\"\") |\n| children (optional) | array | all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs |\n\n\n# markdownChunkToMarkdownStringRecursive\n\n\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: markdownChunk: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| content (optional) | string |  |\n| title (optional) | string | NB: title can also be an empty string (\"\") |\n| children (optional) | array | all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs |\n\n\n# markdownChunksToMarkdownStringRecursive\n\n\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: markdownChunks: array\n\n- MarkdownChunk: object\n\n\n\n\n\n# markdownToSayable\n\nall mp3s should be stored in a separate location because we don't need them in the file system and we don't reference them, as they are data that is located by convention. all markdowns should have a linked `TextToSpeechAudio[]` which is auto updated every time `dev` is ran. `TextToSpeechAudio` also includes infromation about the `duration`, `voice` and more...\n\na bigger `.md.mp3` file is auto-created for every markdown file that concatenates all `sayable` audio pieces in the right order, but also includes the audio pieces in between.\n\n## Returns: array\n\n- null: object\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  markdown,  markdownFilePath,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| markdownFilePath  | string |  |\n| markdown  | object |  |\n\n\n# mdToPdf\n\nHave function `mdToPdf` like the vscode plugin. Probably exists.\n\nHowever, may be good to do it myself since I want different renderings\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  absoluteFilePath,  markdown,  markdownParse,  pdfAbsoluteFilePath,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| absoluteFilePath (optional) | string |  |\n| markdown (optional) | string |  |\n| markdownParse (optional) | object |  |\n| pdfAbsoluteFilePath (optional) | string |  |\n\n\n# mergeMarkdownParse\n\nMerges multiple markdown parses to create a new markdown parse\n\n\n\n## Parameters (2)\n\n### Parameter 1: markdownParses: array\n\n- MarkdownParse: object\n\n\n\n\n\n### Parameter 2: fileName (optional): string\n\n\n\n\n\n\n\n# operationRadio\n\nrandomly plays mp3 summaries of operations on the project\n\n\n\n# operationToMarkdown\n\nconverts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)\n\n\n\n## Parameters (1)\n\n### Parameter 1: config: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | string |  |\n| manualProjectRoot (optional) | string |  |\n| isSummary (optional) | boolean | if true, just returns the outline of the operation (function + interface names, size, deps) |\n| mergeDocsInline (optional) | boolean | if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to) |\n| returnType (optional) | string | save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files<br /><br />string: returns the full markdown string<br /><br />parse: returns the markdownparse |\n\n\n# printNestedTitles\n\nhelper function (recursive) that prints nested titles with .. as prefix and a newline after every title\n\nTODO: allow for numbering titles\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (2)\n\n### Parameter 1: nestedTitles (optional): array\n\n- NestedTitle: object\n\n\n\n\n\n### Parameter 2: depth (optional): number\n\n\n\n\n\n\n\n# print\n\nshould print any file using a preconfigured printer (which can be local or remote. if remote and there is no connection, it should save the task for later)\n\nthis function maybe needs \"generateStaticSite\"\n\n\n\n## Parameters (1)\n\n### Parameter 1: { absoluteFilePath }: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| absoluteFilePath  | string |  |\n\n\n# projectToMarkdown\n\nsummarizes the whole OS project into a markdown string\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  includeTodo,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| includeTodo (optional) | boolean |  |\n| includeOperationDetails (optional) | boolean |  |\n\n\n# propertyToTableRow\n\n\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: property: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| name  | string |  |\n| required  | boolean | NB: can't we put this in the SimplifiedSchema itself? |\n\n\n# sayablesToMp3\n\nCreates a single audiofile of a Sayable[] and stores that in a configured location\n\n\n\n## Parameters (1)\n\n### Parameter 1: {  sayables,  destinationAbsoluteFilePath,}: object\n\n\n\n\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| destinationAbsoluteFilePath  | string |  |\n| sayables  | array |  |\n\n\n# selectRandomOperation\n\nselects a random operation\n\n\n\n## Parameters (1)\n\n### Parameter 1: baseFolderPath (optional): string\n\n\n\n\n\n\n\n# simplifiedSchemaToMarkdownString\n\nShould render a string with one or more markdown tables to represent the simplifiedSchema\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (4)\n\n### Parameter 1: simplifiedSchema (optional): object\n\n\n\n> JSONSchema7 derivative that has the following capabilities and and characteristics...<br /><br />- does not include objects in objects that are also referenced to using xxxSlug or xxxId<br />- recursively finds the references and expands them, unless the references are circular<br />- easier to read<br />- has all the information we need<br />- is able to generate an object with values in the exact format the function needs it<br />- is able to easily generate a form\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| description (optional) | string |  |\n| circularRefName (optional) | string | sometimes we still need to reference to another schema because this thing is recursive. In that case the ref name will be here |\n| enum (optional) | array | in case of enums this could appear... mostly strings, but e.g. numbers can also be an enum I think |\n| properties (optional) | array | in case of object, this will always appear |\n| items (optional) | array | in case of arrays, this will always appear |\n\n\n### Parameter 2: name: string\n\n\n\n\n\n\n\n### Parameter 3: isRequired: boolean\n\n\n\n\n\n\n\n### Parameter 4: level (optional): number\n\n\n\n> the headers level, defaults to 1\n\n\n\n# test\n\n\n\n\n\n# tsFunctionToMarkdownString\n\nTsFunction:\n- name and operation\n- size\n- description (doc-comment)\n- input, output\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: tsFunction: object\n\n\n\n> --- dbStorageMethod: jsonSingle<br />---<br /><br />Interface for arrow functions and normal functions\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | null | name of operation the model belongs to<br /><br />- calculated value (not stored in database)<br />- can be `null` or an actual operationName that it was saved at<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| projectRelativePath  | string | path to dbfile<br /><br />- calculated value (not stored in database)<br />- relatively from the project (without slash at start)<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| operationRelativePath (optional) | string | path to db file<br /><br />- relatively from the operation root folder (without slash at start)<br />- calculated value (not stored in database)<br />- can be `undefined` if the db file does not belong to an operation<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| id  | string | unique id of the model |\n| name  | string | name (identifier) of the model |\n| slug  | string | kebab-case variant of the name |\n| operationRelativeTypescriptFilePath  | string | relative file path from the operation that this indexed instance is referencing to<br /><br />e.g. src/general.ts<br /><br />(no preceding slash) |\n| isExported  | boolean | The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation |\n| isApiExposed  | boolean | for all exported functions in node operations, true by default false for others<br /><br />can be overwritten using frontmatter |\n| rawText (optional) | string | raw text of the function |\n| commentsInside  | array | all comments found in a function and the node that they belong to |\n| parameters (optional) | array | parameters the function takes as its arguments, if any |\n| maxIndentationDepth  | number | maximum amount of times indedented in this function<br /><br />good for determining the complexity and finding code that can be simplified/destructured into smaller pieces |\n| dependantFiles (optional) | array | finds all files that import this function<br /><br />NB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly. |\n\n\n# tsInterfaceToMarkdownString\n\nproperties, their type, and their description\n\nuse simplifiedJsonSchema, but split up nested things into multiple tables (ive written a thing for splitting up nested objects before, use that)\n\n## Returns: string\n\n\n\n\n\n\n\n## Parameters (1)\n\n### Parameter 1: tsInterface: object\n\n\n\n> --- dbStorageMethod: jsonSingle<br />---<br /><br />TODO: Just like parameters, this should be linted for. If you define an interface that's not declared here, that should ring a bell.\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | null | name of operation the model belongs to<br /><br />- calculated value (not stored in database)<br />- can be `null` or an actual operationName that it was saved at<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| projectRelativePath  | string | path to dbfile<br /><br />- calculated value (not stored in database)<br />- relatively from the project (without slash at start)<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| operationRelativePath (optional) | string | path to db file<br /><br />- relatively from the operation root folder (without slash at start)<br />- calculated value (not stored in database)<br />- can be `undefined` if the db file does not belong to an operation<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| id  | string | unique id of the model |\n| name  | string | name (identifier) of the model |\n| slug  | string | kebab-case variant of the name |\n| operationRelativeTypescriptFilePath  | string | relative file path from the operation that this indexed instance is referencing to<br /><br />e.g. src/general.ts<br /><br />(no preceding slash) |\n| commentsInside  | array |  |\n| isExported  | boolean | boolean indicating whether or not this interface is exported from the file, and with that, from the operation |\n| hasGeneric  | boolean | boolean indicating whether or not this interface uses one or more generic variables |\n| rawText (optional) | string | raw interface text, coming from ts-morph |\n| extensions (optional) | array | if the interface extends anything, names will be specified here |\n| isDbModel  | boolean | If true, this interface is marked as a db model, which means it will be included in the db function autocompletion so it's easy to store and fetch data in this format.<br /><br />Is automatically set to true when indexing and when one of the following statements holds true<br /><br />- if the doc-comment contains frontmatter with `isDbModel` or `dbStorageMethod` specified<br />- if the interface last word is \"db\" or \"model\" and if there are minimum 2 words<br />- if the interface extends some other special interface |\n| isOperationIndex  | boolean | If this is true, this is a db-model that is ALWAYS attached to an operation.<br /><br />By default this means it will get a folder in the `db` folder in the operation folder, where the interface will be stored linked to the file-id in specified folder.<br /><br />However, you can also specify a `storageLocationRelativeFilePath` if you want to store the model on an exact location relative to the operation root. |\n| operationStorageLocationRelativeFilePath (optional) | string | If given, specify a file path here where the data should be stored. Must be an operation relative path.<br /><br />This will map onto the \"operationRelativePath\" for that instance.<br /><br />NB: Since this is a single file per project or per operation, it will overwrite your data in case of `jsonSingle` or `markdown` storage. |\n\n\n# upMarkdownChunkLevelRecursively\n\nUps the levels of the markdownChunk array, recursively.\n\nCan be useful for merging multiple markdown sources\n\n\n\n## Parameters (1)\n\n### Parameter 1: markdownChunks (optional): array\n\n- MarkdownChunk: object\n\n\n\n",
  "parameters": {},
  "content": [
    {
      "level": 1,
      "title": "bundleFolderWithMarkdown",
      "children": [
        {
          "level": 0,
          "content": "finds all md files in a folder and creates a single MarkdownParse\n\nhandy for creating a single documentation file or other things that have to include multiple markdown files in a structured way\n\nNB: it recursively structures the files and folders with headings\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (2)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: absoluteFolderPath: string"
            },
            {
              "level": 3,
              "title": "Parameter 2: fileName (optional): string",
              "children": [
                {
                  "level": 0,
                  "content": "> filename to include in the final MarkdownParse\n\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "bundleToBookMarkdown",
      "children": [
        {
          "level": 0,
          "content": "Input: BundleConfig (one or more folder(s), readme, operations with a docs folder)\n\nOutput should be all md files concatenated in the right order with the right titles\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: config: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| bundleConfig  | object | --- dbStorageMethod: jsonSingle<br />--- |\n| title (optional) | string |  |\n| coverImagePath (optional) | string |  |\n| isModulesIncluded (optional) | boolean |  |\n| manualProjectRoot (optional) | string |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "bundleToMarkdown",
      "children": [
        {
          "level": 0,
          "content": "creates a summary for a whole bundle\n\nNB: Related to `bundleToBookMd`\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  bundleConfigId,  includeModules,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| bundleConfigId  | string |  |\n| includeModules (optional) | boolean | if true, also includes the private modules |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "deployToVercel",
      "children": [
        {
          "level": 0,
          "content": "NB: Obviously, this is not the right place for this function, but none of these functions are properly located yet...\n\nshould deploy any bundle or next project folder project to Vercel by first creating and pushing it into git, and then creating it in vercel through their api\n\nshould return an url where the project will be served and the estimated time when it will be live\n\n\n"
        }
      ]
    },
    {
      "level": 1,
      "title": "emailMarkdownParse",
      "children": [
        {
          "level": 0,
          "content": "should email a markdown parse to some email (or multiple)\n\n\n"
        }
      ]
    },
    {
      "level": 1,
      "title": "generateStaticSite",
      "children": [
        {
          "level": 0,
          "content": "generates static site from a markdown file, with a menu on the right by default\n\nuses next.js\n\nbecause it is static, the markdown can be in the frontend assets and there is no need for a backend\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  projectRelativeMdFilePath,  singlePage,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| singlePage (optional) | boolean |  |\n| projectRelativeMdFilePath (optional) | string |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "getOutline",
      "children": [
        {
          "level": 0,
          "content": "low-level function that gets the outline for MarkdownParse\n\nNB: with books usually the pages are referred in the outline. Since that depends on the font size and dimensions, this cannot be done straight from the markdown parse. Eventually we probably need to check the made pdf for its content, maybe there is even a pdf feature that creates an outline for you. There must be more people having this problem.\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: markdownParse: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| fileName (optional) | string | if available, this can be the filename of the markdown in this markdown-parse. Can be used for things like merging |\n| createdAt (optional) | number |  |\n| openedAt (optional) | number |  |\n| updatedAt (optional) | number |  |\n| deletedAt (optional) | number |  |\n| createdFirstAt (optional) | number |  |\n| content (optional) | array | structured content based on h1, h2, h3, etc (paragraphs, recursive) |\n| raw  | string | raw markdown without frontmatter |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "getTitlesRecursively",
      "children": [
        {
          "level": 0,
          "content": "helper function to get a nested array of the titles and its subtitles\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: chunk: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| content (optional) | string |  |\n| title (optional) | string | NB: title can also be an empty string (\"\") |\n| children (optional) | array | all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "markdownChunkToMarkdownStringRecursive",
      "children": [
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: markdownChunk: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| content (optional) | string |  |\n| title (optional) | string | NB: title can also be an empty string (\"\") |\n| children (optional) | array | all content until the next title. it's either a content array if there's any titles found, or a string[] if it's paragraphs |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "markdownChunksToMarkdownStringRecursive",
      "children": [
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: markdownChunks: array",
              "children": [
                {
                  "level": 0,
                  "content": "- MarkdownChunk: object\n\n\n\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "markdownToSayable",
      "children": [
        {
          "level": 0,
          "content": "all mp3s should be stored in a separate location because we don't need them in the file system and we don't reference them, as they are data that is located by convention. all markdowns should have a linked `TextToSpeechAudio[]` which is auto updated every time `dev` is ran. `TextToSpeechAudio` also includes infromation about the `duration`, `voice` and more...\n\na bigger `.md.mp3` file is auto-created for every markdown file that concatenates all `sayable` audio pieces in the right order, but also includes the audio pieces in between.\n"
        },
        {
          "level": 2,
          "title": "Returns: array",
          "children": [
            {
              "level": 0,
              "content": "- null: object\n\n\n\n\n"
            }
          ]
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  markdown,  markdownFilePath,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| markdownFilePath  | string |  |\n| markdown  | object |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "mdToPdf",
      "children": [
        {
          "level": 0,
          "content": "Have function `mdToPdf` like the vscode plugin. Probably exists.\n\nHowever, may be good to do it myself since I want different renderings\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  absoluteFilePath,  markdown,  markdownParse,  pdfAbsoluteFilePath,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| absoluteFilePath (optional) | string |  |\n| markdown (optional) | string |  |\n| markdownParse (optional) | object |  |\n| pdfAbsoluteFilePath (optional) | string |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "mergeMarkdownParse",
      "children": [
        {
          "level": 0,
          "content": "Merges multiple markdown parses to create a new markdown parse\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (2)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: markdownParses: array",
              "children": [
                {
                  "level": 0,
                  "content": "- MarkdownParse: object\n\n\n\n\n"
                }
              ]
            },
            {
              "level": 3,
              "title": "Parameter 2: fileName (optional): string"
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "operationRadio",
      "children": [
        {
          "level": 0,
          "content": "randomly plays mp3 summaries of operations on the project\n\n\n"
        }
      ]
    },
    {
      "level": 1,
      "title": "operationToMarkdown",
      "children": [
        {
          "level": 0,
          "content": "converts an operation and all its contents into a flat markdown file that contains the needed information. configurable.\n\nmarkdown for reading (so there are no links)\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: config: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | string |  |\n| manualProjectRoot (optional) | string |  |\n| isSummary (optional) | boolean | if true, just returns the outline of the operation (function + interface names, size, deps) |\n| mergeDocsInline (optional) | boolean | if true, it will merge all docs into the readme, not linking to them (by default, docs will be linked to) |\n| returnType (optional) | string | save: saves the result in the operation `README.md` and `CONTRIBUTING.md` and other default md files<br /><br />string: returns the full markdown string<br /><br />parse: returns the markdownparse |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "printNestedTitles",
      "children": [
        {
          "level": 0,
          "content": "helper function (recursive) that prints nested titles with .. as prefix and a newline after every title\n\nTODO: allow for numbering titles\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (2)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: nestedTitles (optional): array",
              "children": [
                {
                  "level": 0,
                  "content": "- NestedTitle: object\n\n\n\n\n"
                }
              ]
            },
            {
              "level": 3,
              "title": "Parameter 2: depth (optional): number"
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "print",
      "children": [
        {
          "level": 0,
          "content": "should print any file using a preconfigured printer (which can be local or remote. if remote and there is no connection, it should save the task for later)\n\nthis function maybe needs \"generateStaticSite\"\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: { absoluteFilePath }: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| absoluteFilePath  | string |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "projectToMarkdown",
      "children": [
        {
          "level": 0,
          "content": "summarizes the whole OS project into a markdown string\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  includeTodo,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| includeTodo (optional) | boolean |  |\n| includeOperationDetails (optional) | boolean |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "propertyToTableRow",
      "children": [
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: property: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| name  | string |  |\n| required  | boolean | NB: can't we put this in the SimplifiedSchema itself? |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "sayablesToMp3",
      "children": [
        {
          "level": 0,
          "content": "Creates a single audiofile of a Sayable[] and stores that in a configured location\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: {  sayables,  destinationAbsoluteFilePath,}: object",
              "children": [
                {
                  "level": 0,
                  "content": "Properties: \n\n | Name | Type | Description |\n|---|---|---|\n| destinationAbsoluteFilePath  | string |  |\n| sayables  | array |  |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "selectRandomOperation",
      "children": [
        {
          "level": 0,
          "content": "selects a random operation\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: baseFolderPath (optional): string"
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "simplifiedSchemaToMarkdownString",
      "children": [
        {
          "level": 0,
          "content": "Should render a string with one or more markdown tables to represent the simplifiedSchema\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (4)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: simplifiedSchema (optional): object",
              "children": [
                {
                  "level": 0,
                  "content": "> JSONSchema7 derivative that has the following capabilities and and characteristics...<br /><br />- does not include objects in objects that are also referenced to using xxxSlug or xxxId<br />- recursively finds the references and expands them, unless the references are circular<br />- easier to read<br />- has all the information we need<br />- is able to generate an object with values in the exact format the function needs it<br />- is able to easily generate a form\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| description (optional) | string |  |\n| circularRefName (optional) | string | sometimes we still need to reference to another schema because this thing is recursive. In that case the ref name will be here |\n| enum (optional) | array | in case of enums this could appear... mostly strings, but e.g. numbers can also be an enum I think |\n| properties (optional) | array | in case of object, this will always appear |\n| items (optional) | array | in case of arrays, this will always appear |\n\n"
                }
              ]
            },
            {
              "level": 3,
              "title": "Parameter 2: name: string"
            },
            {
              "level": 3,
              "title": "Parameter 3: isRequired: boolean"
            },
            {
              "level": 3,
              "title": "Parameter 4: level (optional): number",
              "children": [
                {
                  "level": 0,
                  "content": "> the headers level, defaults to 1\n\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "test"
    },
    {
      "level": 1,
      "title": "tsFunctionToMarkdownString",
      "children": [
        {
          "level": 0,
          "content": "TsFunction:\n- name and operation\n- size\n- description (doc-comment)\n- input, output\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: tsFunction: object",
              "children": [
                {
                  "level": 0,
                  "content": "> --- dbStorageMethod: jsonSingle<br />---<br /><br />Interface for arrow functions and normal functions\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | null | name of operation the model belongs to<br /><br />- calculated value (not stored in database)<br />- can be `null` or an actual operationName that it was saved at<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| projectRelativePath  | string | path to dbfile<br /><br />- calculated value (not stored in database)<br />- relatively from the project (without slash at start)<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| operationRelativePath (optional) | string | path to db file<br /><br />- relatively from the operation root folder (without slash at start)<br />- calculated value (not stored in database)<br />- can be `undefined` if the db file does not belong to an operation<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| id  | string | unique id of the model |\n| name  | string | name (identifier) of the model |\n| slug  | string | kebab-case variant of the name |\n| operationRelativeTypescriptFilePath  | string | relative file path from the operation that this indexed instance is referencing to<br /><br />e.g. src/general.ts<br /><br />(no preceding slash) |\n| isExported  | boolean | The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation |\n| isApiExposed  | boolean | for all exported functions in node operations, true by default false for others<br /><br />can be overwritten using frontmatter |\n| rawText (optional) | string | raw text of the function |\n| commentsInside  | array | all comments found in a function and the node that they belong to |\n| parameters (optional) | array | parameters the function takes as its arguments, if any |\n| maxIndentationDepth  | number | maximum amount of times indedented in this function<br /><br />good for determining the complexity and finding code that can be simplified/destructured into smaller pieces |\n| dependantFiles (optional) | array | finds all files that import this function<br /><br />NB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly. |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "tsInterfaceToMarkdownString",
      "children": [
        {
          "level": 0,
          "content": "properties, their type, and their description\n\nuse simplifiedJsonSchema, but split up nested things into multiple tables (ive written a thing for splitting up nested objects before, use that)\n"
        },
        {
          "level": 2,
          "title": "Returns: string"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: tsInterface: object",
              "children": [
                {
                  "level": 0,
                  "content": "> --- dbStorageMethod: jsonSingle<br />---<br /><br />TODO: Just like parameters, this should be linted for. If you define an interface that's not declared here, that should ring a bell.\n\nProperties: \n\n | Name | Type | Description |\n|---|---|---|\n| operationName  | null | name of operation the model belongs to<br /><br />- calculated value (not stored in database)<br />- can be `null` or an actual operationName that it was saved at<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| projectRelativePath  | string | path to dbfile<br /><br />- calculated value (not stored in database)<br />- relatively from the project (without slash at start)<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| operationRelativePath (optional) | string | path to db file<br /><br />- relatively from the operation root folder (without slash at start)<br />- calculated value (not stored in database)<br />- can be `undefined` if the db file does not belong to an operation<br />- can be `undefined` when you are creating an item, because then it can be set for you |\n| id  | string | unique id of the model |\n| name  | string | name (identifier) of the model |\n| slug  | string | kebab-case variant of the name |\n| operationRelativeTypescriptFilePath  | string | relative file path from the operation that this indexed instance is referencing to<br /><br />e.g. src/general.ts<br /><br />(no preceding slash) |\n| commentsInside  | array |  |\n| isExported  | boolean | boolean indicating whether or not this interface is exported from the file, and with that, from the operation |\n| hasGeneric  | boolean | boolean indicating whether or not this interface uses one or more generic variables |\n| rawText (optional) | string | raw interface text, coming from ts-morph |\n| extensions (optional) | array | if the interface extends anything, names will be specified here |\n| isDbModel  | boolean | If true, this interface is marked as a db model, which means it will be included in the db function autocompletion so it's easy to store and fetch data in this format.<br /><br />Is automatically set to true when indexing and when one of the following statements holds true<br /><br />- if the doc-comment contains frontmatter with `isDbModel` or `dbStorageMethod` specified<br />- if the interface last word is \"db\" or \"model\" and if there are minimum 2 words<br />- if the interface extends some other special interface |\n| isOperationIndex  | boolean | If this is true, this is a db-model that is ALWAYS attached to an operation.<br /><br />By default this means it will get a folder in the `db` folder in the operation folder, where the interface will be stored linked to the file-id in specified folder.<br /><br />However, you can also specify a `storageLocationRelativeFilePath` if you want to store the model on an exact location relative to the operation root. |\n| operationStorageLocationRelativeFilePath (optional) | string | If given, specify a file path here where the data should be stored. Must be an operation relative path.<br /><br />This will map onto the \"operationRelativePath\" for that instance.<br /><br />NB: Since this is a single file per project or per operation, it will overwrite your data in case of `jsonSingle` or `markdown` storage. |\n\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "level": 1,
      "title": "upMarkdownChunkLevelRecursively",
      "children": [
        {
          "level": 0,
          "content": "Ups the levels of the markdownChunk array, recursively.\n\nCan be useful for merging multiple markdown sources\n\n\n"
        },
        {
          "level": 2,
          "title": "Parameters (1)",
          "children": [
            {
              "level": 3,
              "title": "Parameter 1: markdownChunks (optional): array",
              "children": [
                {
                  "level": 0,
                  "content": "- MarkdownChunk: object\n\n\n\n"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}