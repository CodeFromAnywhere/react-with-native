[{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"NB: I'm creating circular imports if I start using any k-type things in convert-case, so be careful.","rawStatement":"import { kebabCase } from \"convert-case\";","parameters":{},"types":["nb"],"firstLine":1,"lastLine":1},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"TODO:\n\nAny interface/type\n- should be able to have default values\n- should be able to have validation functions\n- should be able to have casting functions\n- some parameters should be hidden upon creation\n- some should be hidden on updating\n- some should even be hidden when listing\n\nThis is mainly for the admin panel, but it could be integrated on the db level as well.\nThe problem is that this behavior may be app-specific, so this becomes rather opinionated if we do it on the OS level\nCome up with an exact requirement and implementation plan.\n\nThere are many more functionalities possible here to speed up development, not only for admin use-case.","rawStatement":"export type TypescriptIndex = {\n  tsBuildErrors: TsBuildError[];\n  tsLintWarnings: TsLintWarning[];\n  tsFunctions: TsFunction[];\n  tsVariables: TsVariable[];\n  tsInterfaces: TsInterface[];\n  tsComments: TsComment[];\n  tsImports: TsImport[];\n  tsExports: TsExport[];\n};","parameters":{},"types":["todo"],"firstLine":9,"lastLine":25},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"\nTypescript file metadata (all indexes from typescript files, together)","rawStatement":"export type TypescriptIndex = {\n  tsBuildErrors: TsBuildError[];\n  tsLintWarnings: TsLintWarning[];\n  tsFunctions: TsFunction[];\n  tsVariables: TsVariable[];\n  tsInterfaces: TsInterface[];\n  tsComments: TsComment[];\n  tsImports: TsImport[];\n  tsExports: TsExport[];\n};","parameters":{"isDbModel":false},"types":[],"firstLine":27,"lastLine":33},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"All type interfaces that are used to index stuff, which are added to the database\n\nNB: Maybe we could simply get this from the database? Haha, not sure if that's handy, because this is used to generate the database xD","rawStatement":"export const indexDbModels = [\n  \"TsBuildError\",\n  \"TsLintWarning\",\n  \"TsExport\",\n  \"TsImport\",\n  \"TsComment\",\n  \"TsInterface\",\n  \"TsFunction\",\n  \"TsVariable\",\n\n  \"File\",\n] as const;","parameters":{},"types":["nb"],"firstLine":55,"lastLine":59},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"","rawStatement":"export interface TsExport extends IndexId {\n  /**\n   * surrounding comments and comments inside of the import\n   */\n  comments: TsComment[];\n\n  type: \"value\" | \"type\" | undefined;\n  /**\n   * used for duplicate export names\n   */\n  alias?: string;\n  /**\n   * only for type exports. tells you whether or not the type has one or more generic parameter(s)\n   */\n  hasGeneric?: boolean;\n}","parameters":{},"types":[],"firstLine":88,"lastLine":89},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"node: node core packages like fs and path\n\nreact: react standard packages like react, react-native, expo, react-dom, etc.\n\npackage: packages from npm that are not classified as operations\n\noperation: operations from our monorepo\n\ninternal: imports from other places in the same operation\n\nNB: don't confuse this with OperationClassification","rawStatement":"export type ImportClassification =\n  | \"node\"\n  | \"react\"\n  | \"package\"\n  | \"operation\"\n  | \"internal\";","parameters":{},"types":["nb"],"firstLine":107,"lastLine":119},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"","rawStatement":"export interface TsImport extends IndexId {\n  /**\n   * surrounding comments and comments inside of the import\n   */\n  comments: TsComment[];\n\n  module: string;\n  /**\n   * TODO: not sure, but I believe alias should be defined at the import, not at the export, right?\n   */\n  alias?: string;\n\n  classification: ImportClassification;\n  /**\n   * sometimes the import statement module referenced cannot be found, in that case it cannot be known whether the import should contain a type or value, so it will be undefined.\n   */\n  type: \"value\" | \"type\" | undefined;\n  /**\n   * only for type exports. tells you whether or not the type has one or more generic parameter(s)\n   */\n  hasGeneric?: boolean;\n  isAbsolute: boolean;\n  isModuleResolved: boolean;\n  isModuleFromMonorepo: boolean;\n}","parameters":{},"types":[],"firstLine":127,"lastLine":128},{"id":"FqDYPUjaPzmQJHlv","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/code-types/src/TypescriptIndex.ts","srcFileId":"/TypescriptIndex","operationFolderName":"code-types","relativeFilePathFromSrc":"/TypescriptIndex.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/code-types","operationName":"code-types","comment":"","rawStatement":"export interface TsVariable extends IndexId {\n  value: string;\n  classification: \"const\" | \"var\" | \"let\";\n  type: TypeInfo;\n  /**\n   * surrounding comments and comments inside of the variable\n   */\n  comments: TsComment[];\n}","parameters":{},"types":[],"firstLine":155,"lastLine":156}]