[{"id":"BBBlVPDuBmYVcTqc","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/typescript/schema-util/src/simplifySchema.ts","srcFileId":"/simplifySchema","operationFolderName":"schema-util","relativeFilePathFromSrc":"/simplifySchema.ts","relativeOperationBasePathFromProjectRoot":"/tools/typescript/schema-util","operationName":"schema-util","comment":"return a SimplifiedSchema by giving the JSONSchema7 schema, its name and a list of possible references in the JSONSchema","rawStatement":"export const simplifySchema = (\n  /** The name of the type interface, (this could be used as $ref). */\n  name: string | null,\n\n  /** The schema that needs to be simplified */\n  schema: JSONSchema7,\n\n  /** The array of other schemas found when crawling file this schema was found in. this also includes all refs to other type interfaces in all schemas in that file */\n  possibleRefs: {\n    /** the name of the schema, (without /definitions/ prefix like $ref) */\n    name: string;\n    schema: JSONSchema7;\n  }[],\n  /**\n   * This function is recursive. If we find any reference to another schema, we will add the name of the current schema to the rootStack and explore that schema.\n   */\n  rootStack: string[]\n): SimplifiedSchema => {\n  if (Array.isArray(schema.type)) {\n    // let's do this one later\n    log(\n      `I don't support this usecase (type is an array of multiple types)... ${schema.type.join(\n        \",\"\n      )}`,\n      {\n        type: \"warning\",\n      }\n    );\n  }\n  const type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n  const newRootStack = name ? rootStack.concat(name) : rootStack;\n  const refName = getRefLink(schema.$ref);\n  const isCircularRef = !!refName && rootStack.includes(refName);\n\n  if (refName && !isCircularRef) {\n    const refSchema = possibleRefs.find((r) => r.name === refName);\n    if (!refSchema) {\n      log(\"Strange, ref was not present in the possible refs\", {\n        type: \"warning\",\n      });\n    }\n\n    // we already encountered this ref before, let's avoid infinite recursion here.\n    // @ts-ignore\n\n    return refSchema?.schema\n      ? simplifySchema(refName, refSchema?.schema, possibleRefs, newRootStack)\n      : undefined;\n  }\n\n  const simplifiedPrimitive = {\n    description: schema.description,\n    enum: schema.enum,\n    circularRefName: refName,\n  };\n\n  if (type === \"boolean\") {\n    return { ...simplifiedPrimitive, type: \"boolean\" };\n  }\n\n  if (type === \"integer\" || type === \"number\") {\n    // NB: integers are also numbers\n    return { ...simplifiedPrimitive, type: \"number\" };\n  }\n\n  if (type === \"null\") {\n    return { ...simplifiedPrimitive, type: \"null\" };\n  }\n\n  if (type === \"string\") {\n    return { ...simplifiedPrimitive, type: \"string\" };\n  }\n\n  if (type === \"array\") {\n    const items = getSchemaItems(schema);\n\n    const simplifiedItems: SimplifiedSchemaItem[] = items.map((item) => {\n      const itemName = getRefLink(item.$ref) || null;\n      return {\n        schema: simplifySchema(\n          itemName,\n          item,\n          possibleRefs,\n          name ? rootStack.concat(name) : rootStack\n        ),\n        name: itemName,\n      };\n    });\n\n    return {\n      ...simplifiedPrimitive,\n      items: simplifiedItems,\n      type: \"array\",\n    };\n  }\n\n  // NB: type must be an object here, it's the only possibility left...\n  // in case of objects\n\n  const properties = getProperties(schema);\n\n  const simplifiedProperties: SimplifiedSchemaProperty[] = properties\n    .map((property) => {\n      const possibleRelationParameters = [\"Slug\", \"Id\"].map((suffix) =>\n        property.name.concat(suffix)\n      );\n\n      const propertyHasModelReference = properties.find((x) =>\n        possibleRelationParameters.includes(x.name)\n      );\n      // NB: if the property has a model reference, we just need the model reference, not the whole model. This is only for retreiving, it's not present in the database.\n      if (propertyHasModelReference) return;\n\n      return {\n        name: property.name,\n        required: property.required,\n        schema: simplifySchema(\n          property.name,\n          property.schema,\n          possibleRefs,\n          newRootStack\n        ),\n      };\n    })\n    .filter(notEmpty);\n  return {\n    ...simplifiedPrimitive,\n    properties: simplifiedProperties,\n    type: \"object\",\n  };\n};","parameters":{},"types":[],"firstLine":10,"lastLine":12}]