[{"id":"SOQFHjbpINwhMnVs","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-orm/src/getDatabaseFiles.ts","srcFileId":"/getDatabaseFiles","operationFolderName":"fs-orm","relativeFilePathFromSrc":"/getDatabaseFiles.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-orm","operationName":"fs-orm","comment":"monorepo","rawStatement":"import { log } from \"log\";","parameters":{},"types":[],"firstLine":1,"lastLine":1},{"id":"SOQFHjbpINwhMnVs","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-orm/src/getDatabaseFiles.ts","srcFileId":"/getDatabaseFiles","operationFolderName":"fs-orm","relativeFilePathFromSrc":"/getDatabaseFiles.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-orm","operationName":"fs-orm","comment":"relative","rawStatement":"import { GetConfig } from \"./types\";","parameters":{},"types":[],"firstLine":13,"lastLine":13},{"id":"SOQFHjbpINwhMnVs","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/control-fs/fs-orm/src/getDatabaseFiles.ts","srcFileId":"/getDatabaseFiles","operationFolderName":"fs-orm","relativeFilePathFromSrc":"/getDatabaseFiles.ts","relativeOperationBasePathFromProjectRoot":"/tools/control-fs/fs-orm","operationName":"fs-orm","comment":"this function gets the files that the data can be stored, by convention, based on the model and the config","rawStatement":"export const getDatabaseFiles = async (\n  modelName: string,\n  config: Partial<GetConfig>,\n  getProjectRelativePaths?: boolean\n): Promise<string[]> => {\n  const projectRoot = config?.manualProjectRoot || getProjectRoot();\n\n  if (!projectRoot) return [];\n\n  // we need to make the convention here\n  const modelNameKebabCase = kebabCase(modelName);\n  const modelFolderName = `${modelNameKebabCase}s`;\n\n  /**\n   * based on configuration and convention, we will fill this array with the files to get data from\n   */\n  let dbFiles: string[] = [];\n\n  // If operation is provided, it's always JSON files, and it's always an Index Model (for now)\n\n  if (config.operation) {\n    /** array with one or more operations */\n    const operationFolderPaths =\n      config.operation === \"*\"\n        ? await exploreOperationFolders({\n            basePath: getPathsWithOperations({\n              // NB: this makes it possible to get other operations\n              manualProjectRoot: config?.manualProjectRoot,\n            }),\n          })\n        : await getOperationPath(config.operation, {\n            manualProjectRoot: config?.manualProjectRoot,\n          });\n\n    if (!operationFolderPaths) {\n      log(`Operation(s) not found (${config.operation}`, {\n        type: \"error\",\n      });\n      return [];\n    }\n\n    // NB: some of these may not exist!\n    const modelIndexFolderPaths = getPathCombinations(\n      operationFolderPaths,\n      \"index\",\n      modelFolderName\n    ).filter((x) => fs.existsSync(x));\n\n    dbFiles = (\n      await explore({\n        basePath: modelIndexFolderPaths,\n        ignore: config.ignoreOperationIndexFiles,\n        search: config.operationIndexFiles,\n        extension: \"json\",\n      })\n    ).map((x) => x.path);\n\n    // console.log({\n    //   operation: mergedConfig.operation,\n    //   modelIndexFolderPaths,\n    //   dbFiles,\n    // });\n\n    // searches all or specific operation `index/{kebabCase(model)}`\n  } else if (config.folders) {\n    // only looks for `{kebabCase(model)}s?.ext` in these folders (recursively) or *.ext if `all` is true\n\n    dbFiles = (\n      await explore({\n        basePath: config.folders,\n        search: config.all ? undefined : getPossibleModelFiles(modelName),\n        exact: !config.all,\n        extension: [\"json\", \"md\", \"csv\"],\n      })\n    ).map((x) => x.path);\n  } else {\n    // Default location for any model\n\n    const informationPath = getRootPath(\"information\", {\n      manualProjectRoot: config?.manualProjectRoot,\n    })!;\n\n    const allInformationModelFolderFiles = (\n      await explore({\n        basePath: getPathCombinations(informationPath, [\n          modelNameKebabCase,\n          `${modelNameKebabCase}s`,\n        ]),\n        extension: [\"json\", \"csv\", \"md\"],\n      })\n    ).map((x) => x.path);\n\n    // looks for `/information/[model]s?.json` and `/information/[model]s?/*.json\n    dbFiles = getPathCombinations(\n      informationPath,\n      getPossibleModelFiles(modelName)\n    ).concat(allInformationModelFolderFiles);\n  }\n\n  if (getProjectRelativePaths) {\n    return dbFiles.map((f) => f.substring(projectRoot.length));\n  }\n  return dbFiles;\n};","parameters":{},"types":[],"firstLine":17,"lastLine":19}]