{
  "createdAt": 1669385353342,
  "updatedAt": 1669385353342,
  "deletedAt": 0,
  "createdFirstAt": 1669385353342,
  "isApiExposed": true,
  "isExported": true,
  "groupAuthorization": {},
  "operationRelativeTypescriptFilePath": "src/updateMeWithContext.ts",
  "commentsInside": [],
  "rawText": " async (\n  functionContext: FunctionContext,\n  details: PersonProfileDetails\n): Promise<{ isSuccessful: boolean; message: string }> => {\n  const person = functionContext.device.currentPersonCalculated;\n\n  const processedAsset = await processAsset(details.pictureImage);\n  if (processedAsset) details.pictureImage = processedAsset;\n\n  if (!person) {\n    return {\n      isSuccessful: false,\n      message: \"Couldn't find you, are you logged in?\",\n    };\n  }\n\n  const { isSuccesful, message, amountUpdated } = await db.update(\n    \"Person\",\n    (item) => item.id === person.id,\n    (old) => ({ ...old, ...details })\n  );\n\n  const isReallySuccessful = (isSuccesful && amountUpdated === 1) || false;\n\n  return {\n    isSuccessful: isReallySuccessful,\n    message: isReallySuccessful\n      ? \"Updated your profile details\"\n      : message || \"Something went wrong (no message)\",\n  };\n}",
  "name": "updateMeWithContext",
  "slug": "update-me-with-context",
  "parameters": [
    {
      "name": "functionContext",
      "schema": {
        "$ref": "#/definitions/FunctionContext"
      },
      "simplifiedSchema": {
        "fullComment": "Should be attached as first argument of the function, if the name of the function is in the format of:\n\n- `xyzWithContext`: attaches all context\n- `xyzWithContextRaw`: attaches all context, api returns just the result of the function without wrapping it in the `RealApiReturnType`. Needed in case you have a different server.js `server.reply`\n\nFor more info see `apiConvention`",
        "properties": [
          {
            "name": "tsFunction",
            "required": false,
            "schema": {
              "fullComment": "--- dbStorageMethod: jsonSingle\n---\n\nInterface for arrow functions and normal functions",
              "properties": [
                {
                  "name": "explicitTypeName",
                  "required": false,
                  "schema": {
                    "fullComment": "If you give a function a type explicitly on its declaration, this type will be set here.",
                    "type": "string"
                  }
                },
                {
                  "name": "isExported",
                  "required": true,
                  "schema": {
                    "fullComment": "The function is immediately exported upon creation. If the os dev tools are being used, this means it is also exported from the operation",
                    "type": "boolean"
                  }
                },
                {
                  "name": "description",
                  "required": false,
                  "schema": {
                    "fullComment": "parsed comment from doc-comment\n\n",
                    "properties": [
                      {
                        "name": "fileName",
                        "required": true,
                        "schema": {
                          "type": "string"
                        }
                      },
                      {
                        "name": "params",
                        "required": true,
                        "schema": {
                          "properties": [
                            {
                              "name": "title",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "author",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "createdAt",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "type": "number"
                        }
                      },
                      {
                        "name": "updatedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "type": "number"
                        }
                      },
                      {
                        "name": "modifiedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "type": "number"
                        }
                      },
                      {
                        "name": "openedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "type": "number"
                        }
                      },
                      {
                        "name": "content",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "type": "string"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "rawText",
                  "required": false,
                  "schema": {
                    "fullComment": "raw text of the function",
                    "type": "string"
                  }
                },
                {
                  "name": "commentsInside",
                  "required": true,
                  "schema": {
                    "fullComment": "all comments found in a function and the node that they belong to",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "comments are basically one-or-multi-line human content inside of typescript files, so it's a very important to do something useful with them.\n\n\nThe convention should be that single-line comments should start with that. This then becomes the type of the comment. You can also put multiple prefixes at the start.\n\nExample:\n\n`// TODO: NB: this is a todo but its also important`\n\nMultiline comments can also have one or multiple types in their text, but they should not be split into multiple comments as the context could be needed some times.\n\n\n\nThere are also some other things comments can say about statements, but these should be inside the frontmatter, and are much more flexible.\n- classified[0-10] indicating level of classification. This way I can share subsets of the codebase, maybe...\n- privacy\n- ...?\n\nNB: with the current setup we can also parse `.md` files as being a TsComment, keep it that way!\n\nNB: comments are part of the code, so they should always be in English!",
                          "nb": "with the current setup we can also parse `.md` files as being a TsComment, keep it that way!",
                          "properties": [
                            {
                              "name": "operationName",
                              "required": true,
                              "schema": {
                                "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                "type": "null"
                              }
                            },
                            {
                              "name": "projectRelativePath",
                              "required": true,
                              "schema": {
                                "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                "type": "string"
                              }
                            },
                            {
                              "name": "operationRelativePath",
                              "required": false,
                              "schema": {
                                "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                "type": "string"
                              }
                            },
                            {
                              "name": "id",
                              "required": true,
                              "schema": {
                                "fullComment": "unique id of the model",
                                "type": "string"
                              }
                            },
                            {
                              "name": "name",
                              "required": true,
                              "schema": {
                                "fullComment": "name (identifier) of the model",
                                "type": "string"
                              }
                            },
                            {
                              "name": "slug",
                              "required": true,
                              "schema": {
                                "fullComment": "kebab-case variant of the name",
                                "type": "string"
                              }
                            },
                            {
                              "name": "operationRelativeTypescriptFilePath",
                              "required": true,
                              "schema": {
                                "fullComment": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)",
                                "type": "string"
                              }
                            },
                            {
                              "name": "comment",
                              "required": true,
                              "schema": {
                                "fullComment": "the content of the comment in markdown, without frontmatter\n\n",
                                "properties": [
                                  {
                                    "name": "fileName",
                                    "required": true,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "params",
                                    "required": true,
                                    "schema": {
                                      "properties": [
                                        {
                                          "name": "title",
                                          "required": false,
                                          "schema": {
                                            "type": "string"
                                          }
                                        },
                                        {
                                          "name": "author",
                                          "required": false,
                                          "schema": {
                                            "type": "string"
                                          }
                                        }
                                      ],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "createdAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "updatedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "modifiedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "openedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "",
                                      "type": "string"
                                    }
                                  }
                                ],
                                "type": "object"
                              }
                            },
                            {
                              "name": "parameters",
                              "required": true,
                              "schema": {
                                "fullComment": "parameters destructured from the frontmatter of the parsed markdown (if comment is not a oneliner, otherwise it'll be empty)\n\nOur version of frontmatter is a bit simpler than regular frontmatter\n\nNot sure if this is a good idea, but it keeps it simple for our OS\n\nall values parse in a similar way to csv\n\nmake sure that you use quotes if you want to store a string with commas, because commas in a parameter indicate that it is a string array\n\nNB: string arrays are comma separated values, where you can put values with special characters in between quotes",
                                "nb": "string arrays are comma separated values, where you can put values with special characters in between quotes",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "types",
                              "required": true,
                              "schema": {
                                "fullComment": "These are the type indicators that were found in this single or multiline comment. Can be multiple.",
                                "items": [
                                  {
                                    "schema": {
                                      "enum": [
                                        "todo",
                                        "discussion",
                                        "idea",
                                        "later",
                                        "nb",
                                        "title",
                                        "section",
                                        "description"
                                      ],
                                      "fullComment": "special line prefixes:\n\n**Developer related comments**\n\n- TODO: for developer to know what to do\n- DISCUSSION: for developer to state that discussion is needed\n- IDEA: for developer to state ideas\n- LATER: for developer to mark as thing that needs to be done later\n- NB: for developer to add a note\n\n**Form related comments**\n\n- TITLE: if available, will be used as title of form input (overwrites humanCase version of the property-name itself in that case)\n- SECTION: start a new section in the form from this point, the value behind here can be the title\n- DESCRIPTION: if available, will be used as description of the form input",
                                      "type": "string"
                                    },
                                    "name": "CommentType"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "firstLine",
                              "required": true,
                              "schema": {
                                "fullComment": "first line of the comment",
                                "type": "number"
                              }
                            },
                            {
                              "name": "lastLine",
                              "required": true,
                              "schema": {
                                "fullComment": "last line of the comment",
                                "type": "number"
                              }
                            },
                            {
                              "name": "statementName",
                              "required": false,
                              "schema": {
                                "fullComment": "statement name the comment belongs to",
                                "type": "string"
                              }
                            },
                            {
                              "name": "rawStatement",
                              "required": false,
                              "schema": {
                                "fullComment": "raw statement text the comment belongs to",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        },
                        "name": "TsComment"
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "returnType",
                  "required": true,
                  "schema": {
                    "fullComment": "return type JSON Schema definition\n\nall info that should always be collected when indexing any type interface",
                    "properties": [
                      {
                        "name": "typeDefinition",
                        "required": false,
                        "schema": {
                          "fullComment": "JSON schema definition of a type interface\n\n\nSome info about the Schema:\n\n- if the type is an object, there should be properties\n- if the type is an array, there should be items\n\n\n\n",
                          "properties": [
                            {
                              "name": "$id",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "$ref",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "$comment",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "$defs",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "type",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "enum",
                              "required": false,
                              "schema": {
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "Primitive type",
                                      "properties": [],
                                      "type": "object"
                                    },
                                    "name": "JSONSchema7Type"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "const",
                              "required": false,
                              "schema": {
                                "fullComment": "Primitive type",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "multipleOf",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "maximum",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "exclusiveMaximum",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "minimum",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "exclusiveMinimum",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "maxLength",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "minLength",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "pattern",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "items",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "additionalItems",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "maxItems",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "minItems",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "uniqueItems",
                              "required": false,
                              "schema": {
                                "type": "boolean"
                              }
                            },
                            {
                              "name": "contains",
                              "required": false,
                              "schema": {
                                "circularRefName": "JSONSchema7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "maxProperties",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "minProperties",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "required",
                              "required": false,
                              "schema": {
                                "items": [
                                  {
                                    "schema": {
                                      "type": "string"
                                    },
                                    "name": null
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "properties",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "patternProperties",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "additionalProperties",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "dependencies",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "propertyNames",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "if",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "then",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "else",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "allOf",
                              "required": false,
                              "schema": {
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    },
                                    "name": "JSONSchema7Definition"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "anyOf",
                              "required": false,
                              "schema": {
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    },
                                    "name": "JSONSchema7Definition"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "oneOf",
                              "required": false,
                              "schema": {
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    },
                                    "name": "JSONSchema7Definition"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "not",
                              "required": false,
                              "schema": {
                                "fullComment": "JSON Schema v7",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "format",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "contentMediaType",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "contentEncoding",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "definitions",
                              "required": false,
                              "schema": {
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "title",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "description",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "default",
                              "required": false,
                              "schema": {
                                "fullComment": "Primitive type",
                                "properties": [],
                                "type": "object"
                              }
                            },
                            {
                              "name": "readOnly",
                              "required": false,
                              "schema": {
                                "type": "boolean"
                              }
                            },
                            {
                              "name": "writeOnly",
                              "required": false,
                              "schema": {
                                "type": "boolean"
                              }
                            },
                            {
                              "name": "examples",
                              "required": false,
                              "schema": {
                                "fullComment": "Primitive type",
                                "properties": [],
                                "type": "object"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "simplifiedSchema",
                        "required": false,
                        "schema": {
                          "fullComment": "JSONSchema7 derivative that has the following capabilities and and characteristics...\n\n- does not include objects in objects that are also referenced to using xxxSlug or xxxId\n- recursively finds the references and expands them, unless the references are circular\n- easier to read\n- has all the information we need\n- is able to generate an object with values in the exact format the function needs it\n- is able to easily generate a form",
                          "properties": [
                            {
                              "name": "todo",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "discussion",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "idea",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "later",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "nb",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "title",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "section",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "description",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "type",
                              "required": true,
                              "schema": {
                                "enum": [
                                  "string",
                                  "number",
                                  "boolean",
                                  "object",
                                  "array",
                                  "null"
                                ],
                                "fullComment": "- string\n- number\n- boolean\n- object\n- array\n- null\n\nNB: Omit doesn't work for the indexer! This would be the type: Omit<JSONSchema7TypeName, \"integer\">;\n\n",
                                "nb": "Omit doesn't work for the indexer! This would be the type: Omit<JSONSchema7TypeName, \"integer\">;",
                                "type": "string"
                              }
                            },
                            {
                              "name": "circularRefName",
                              "required": false,
                              "schema": {
                                "fullComment": "sometimes we still need to reference to another schema because this thing is recursive. In that case the ref name will be here",
                                "type": "string"
                              }
                            },
                            {
                              "name": "enum",
                              "required": false,
                              "schema": {
                                "fullComment": "in case of enums this could appear... mostly strings, but e.g. numbers can also be an enum I think",
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "Primitive type",
                                      "properties": [],
                                      "type": "object"
                                    },
                                    "name": "JSONSchema7Type"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "properties",
                              "required": false,
                              "schema": {
                                "fullComment": "in case of object, this will always appear",
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "",
                                      "properties": [
                                        {
                                          "name": "name",
                                          "required": true,
                                          "schema": {
                                            "type": "string"
                                          }
                                        },
                                        {
                                          "name": "schema",
                                          "required": true,
                                          "schema": {
                                            "circularRefName": "SimplifiedSchema",
                                            "properties": [],
                                            "type": "object"
                                          }
                                        },
                                        {
                                          "name": "required",
                                          "required": true,
                                          "schema": {
                                            "fullComment": "NB: can't we put this in the SimplifiedSchema itself?",
                                            "nb": "can't we put this in the SimplifiedSchema itself?",
                                            "type": "boolean"
                                          }
                                        }
                                      ],
                                      "type": "object"
                                    },
                                    "name": "SimplifiedSchemaProperty"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "items",
                              "required": false,
                              "schema": {
                                "fullComment": "in case of arrays, this will always appear",
                                "items": [
                                  {
                                    "schema": {
                                      "fullComment": "",
                                      "properties": [
                                        {
                                          "name": "name",
                                          "required": true,
                                          "schema": {
                                            "fullComment": "name in case of it being a reference, otherwise null",
                                            "type": "string"
                                          }
                                        },
                                        {
                                          "name": "schema",
                                          "required": true,
                                          "schema": {
                                            "circularRefName": "SimplifiedSchema",
                                            "properties": [],
                                            "type": "object"
                                          }
                                        }
                                      ],
                                      "type": "object"
                                    },
                                    "name": "SimplifiedSchemaItem"
                                  }
                                ],
                                "type": "array"
                              }
                            },
                            {
                              "name": "fullComment",
                              "required": false,
                              "schema": {
                                "fullComment": "Full doccomment, parsed without all stars syntax.\n\nNB: besides this, every `CommentType` can optionally also be found as a property on the `SimplifiedSchema`",
                                "nb": "besides this, every `CommentType` can optionally also be found as a property on the `SimplifiedSchema`",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "isObject",
                        "required": true,
                        "schema": {
                          "fullComment": "if the type is an object, this is true. false if it's an array",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "isArray",
                        "required": true,
                        "schema": {
                          "fullComment": "if the type is an array, this is true",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "isPrimitive",
                        "required": true,
                        "schema": {
                          "fullComment": "if it's a primitive type like \"string\", \"number\", \"boolean\", \"null\" | \"undefined\"",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "isEnum",
                        "required": true,
                        "schema": {
                          "fullComment": "will be true for any primitive conjunction types",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "isEnumLiteral",
                        "required": true,
                        "schema": {
                          "fullComment": "will be true for string conjunction types",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "typeCoverage",
                        "required": true,
                        "schema": {
                          "fullComment": "quantification of coverage of the specified type or subtypes in our database.",
                          "type": "number"
                        }
                      },
                      {
                        "name": "rawType",
                        "required": true,
                        "schema": {
                          "fullComment": "raw type string",
                          "type": "string"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "parameters",
                  "required": false,
                  "schema": {
                    "fullComment": "parameters the function takes as its arguments, if any",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "name",
                              "required": true,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "schema",
                              "required": false,
                              "schema": {
                                "fullComment": "",
                                "properties": [
                                  {
                                    "name": "$id",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "$ref",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "$comment",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "$defs",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "type",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "enum",
                                    "required": false,
                                    "schema": {
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "Primitive type",
                                            "properties": [],
                                            "type": "object"
                                          },
                                          "name": "JSONSchema7Type"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "const",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "Primitive type",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "multipleOf",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "maximum",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "exclusiveMaximum",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "minimum",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "exclusiveMinimum",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "maxLength",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "minLength",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "pattern",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "items",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "additionalItems",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "maxItems",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "minItems",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "uniqueItems",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "contains",
                                    "required": false,
                                    "schema": {
                                      "circularRefName": "JSONSchema7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "maxProperties",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "minProperties",
                                    "required": false,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "required",
                                    "required": false,
                                    "schema": {
                                      "items": [
                                        {
                                          "schema": {
                                            "type": "string"
                                          },
                                          "name": null
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "properties",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "patternProperties",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "additionalProperties",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "dependencies",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "propertyNames",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "if",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "then",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "else",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "allOf",
                                    "required": false,
                                    "schema": {
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "JSON Schema v7",
                                            "properties": [],
                                            "type": "object"
                                          },
                                          "name": "JSONSchema7Definition"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "anyOf",
                                    "required": false,
                                    "schema": {
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "JSON Schema v7",
                                            "properties": [],
                                            "type": "object"
                                          },
                                          "name": "JSONSchema7Definition"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "oneOf",
                                    "required": false,
                                    "schema": {
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "JSON Schema v7",
                                            "properties": [],
                                            "type": "object"
                                          },
                                          "name": "JSONSchema7Definition"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "not",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "JSON Schema v7",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "format",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "contentMediaType",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "contentEncoding",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "definitions",
                                    "required": false,
                                    "schema": {
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "title",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "description",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "default",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "Primitive type",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  },
                                  {
                                    "name": "readOnly",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "writeOnly",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "examples",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "Primitive type",
                                      "properties": [],
                                      "type": "object"
                                    }
                                  }
                                ],
                                "type": "object"
                              }
                            },
                            {
                              "name": "simplifiedSchema",
                              "required": false,
                              "schema": {
                                "fullComment": "JSONSchema7 derivative that has the following capabilities and and characteristics...\n\n- does not include objects in objects that are also referenced to using xxxSlug or xxxId\n- recursively finds the references and expands them, unless the references are circular\n- easier to read\n- has all the information we need\n- is able to generate an object with values in the exact format the function needs it\n- is able to easily generate a form",
                                "properties": [
                                  {
                                    "name": "todo",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "discussion",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "idea",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "later",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "nb",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "title",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "section",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "description",
                                    "required": false,
                                    "schema": {
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "type",
                                    "required": true,
                                    "schema": {
                                      "enum": [
                                        "string",
                                        "number",
                                        "boolean",
                                        "object",
                                        "array",
                                        "null"
                                      ],
                                      "fullComment": "- string\n- number\n- boolean\n- object\n- array\n- null\n\nNB: Omit doesn't work for the indexer! This would be the type: Omit<JSONSchema7TypeName, \"integer\">;\n\n",
                                      "nb": "Omit doesn't work for the indexer! This would be the type: Omit<JSONSchema7TypeName, \"integer\">;",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "circularRefName",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "sometimes we still need to reference to another schema because this thing is recursive. In that case the ref name will be here",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "enum",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "in case of enums this could appear... mostly strings, but e.g. numbers can also be an enum I think",
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "Primitive type",
                                            "properties": [],
                                            "type": "object"
                                          },
                                          "name": "JSONSchema7Type"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "properties",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "in case of object, this will always appear",
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "",
                                            "properties": [
                                              {
                                                "name": "name",
                                                "required": true,
                                                "schema": {
                                                  "type": "string"
                                                }
                                              },
                                              {
                                                "name": "schema",
                                                "required": true,
                                                "schema": {
                                                  "circularRefName": "SimplifiedSchema",
                                                  "properties": [],
                                                  "type": "object"
                                                }
                                              },
                                              {
                                                "name": "required",
                                                "required": true,
                                                "schema": {
                                                  "fullComment": "NB: can't we put this in the SimplifiedSchema itself?",
                                                  "nb": "can't we put this in the SimplifiedSchema itself?",
                                                  "type": "boolean"
                                                }
                                              }
                                            ],
                                            "type": "object"
                                          },
                                          "name": "SimplifiedSchemaProperty"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "items",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "in case of arrays, this will always appear",
                                      "items": [
                                        {
                                          "schema": {
                                            "fullComment": "",
                                            "properties": [
                                              {
                                                "name": "name",
                                                "required": true,
                                                "schema": {
                                                  "fullComment": "name in case of it being a reference, otherwise null",
                                                  "type": "string"
                                                }
                                              },
                                              {
                                                "name": "schema",
                                                "required": true,
                                                "schema": {
                                                  "circularRefName": "SimplifiedSchema",
                                                  "properties": [],
                                                  "type": "object"
                                                }
                                              }
                                            ],
                                            "type": "object"
                                          },
                                          "name": "SimplifiedSchemaItem"
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "fullComment",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "Full doccomment, parsed without all stars syntax.\n\nNB: besides this, every `CommentType` can optionally also be found as a property on the `SimplifiedSchema`",
                                      "nb": "besides this, every `CommentType` can optionally also be found as a property on the `SimplifiedSchema`",
                                      "type": "string"
                                    }
                                  }
                                ],
                                "type": "object"
                              }
                            },
                            {
                              "name": "required",
                              "required": true,
                              "schema": {
                                "type": "boolean"
                              }
                            }
                          ],
                          "type": "object"
                        },
                        "name": "FunctionParameter"
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "size",
                  "required": true,
                  "schema": {
                    "fullComment": "size of this function (comments + code)\n\ntype interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "commentSize",
                  "required": false,
                  "schema": {
                    "fullComment": "size of the comments of this function (including surrounding comments)\n\ntype interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "codeSize",
                  "required": false,
                  "schema": {
                    "fullComment": "size of the code inside the function (without comments)\n\ntype interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "cumulativeSize",
                  "required": false,
                  "schema": {
                    "fullComment": "tells you the size of itself and all its dependencies that are used that are also part of an operation, recursively\n\ntype interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "cumulativeCommentSize",
                  "required": false,
                  "schema": {
                    "fullComment": "type interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "cumulativeCodeSize",
                  "required": false,
                  "schema": {
                    "fullComment": "type interface that can be used to summarize multiple files",
                    "properties": [
                      {
                        "name": "numberOfFiles",
                        "required": false,
                        "schema": {
                          "fullComment": "if this is about multiple files, the number of files is specified here",
                          "type": "number"
                        }
                      },
                      {
                        "name": "characters",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of characters",
                          "type": "number"
                        }
                      },
                      {
                        "name": "lines",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of lines",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytes",
                        "required": true,
                        "schema": {
                          "fullComment": "amount of bytes",
                          "type": "number"
                        }
                      },
                      {
                        "name": "linesPerFile",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of lines per file (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "charactersPerLine",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of characters per line (averaged)",
                          "type": "number"
                        }
                      },
                      {
                        "name": "bytesPerCharacter",
                        "required": true,
                        "schema": {
                          "fullComment": "rounded, amount of bytes per character",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "maxIndentationDepth",
                  "required": true,
                  "schema": {
                    "fullComment": "maximum amount of times indedented in this function\n\ngood for determining the complexity and finding code that can be simplified/destructured into smaller pieces",
                    "type": "number"
                  }
                },
                {
                  "name": "dependantFiles",
                  "required": false,
                  "schema": {
                    "fullComment": "finds all files that import this function\n\nNB: this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly.",
                    "nb": "this is not indexed because this information has nothing to do with the operation itself, but the exposure to the broader monorepo. This is calculated on the fly.",
                    "items": [
                      {
                        "schema": {
                          "type": "string"
                        },
                        "name": null
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "groupAuthorization",
                  "required": true,
                  "schema": {
                    "fullComment": "Other keys in frontmatter that are group names, can be added here",
                    "properties": [],
                    "type": "object"
                  }
                },
                {
                  "name": "isApiExposed",
                  "required": true,
                  "schema": {
                    "fullComment": "for all exported functions in node operations, true by default false for others\n\ncan be overwritten using frontmatter",
                    "type": "boolean"
                  }
                },
                {
                  "name": "canCache",
                  "required": false,
                  "schema": {
                    "fullComment": "whether or not the function can be cached (relies on cache invalidation)",
                    "type": "boolean"
                  }
                },
                {
                  "name": "runEveryPeriod",
                  "required": false,
                  "schema": {
                    "enum": [
                      "minute",
                      "5-minutes",
                      "quarter-hour",
                      "hour",
                      "6-hours",
                      "midnight",
                      "week",
                      "month",
                      "3-months",
                      "year"
                    ],
                    "fullComment": "You can specify `runEveryPeriod` in your frontmatter of a function. This will set `runEveryPeriod` for the TsFunction. This is used by `function-server`: it will execute CRON-jobs that run these things on those periods.\n\nWill only work if the function takes no arguments.\n\nUsed to specify functions that need to run every time with a specific interval\n\nAll times are at at the server timezone time\n\n- `minute`: every minute at 0 seconds\n- `5-mintues`: every 5 minutes, starting at the first minute of the hour\n- `quarter-hour`: every 15 minutes, starting at the first minute of the hour\n- `hour`: every hour, starting at the first minute of the hour\n- `6-hours`: every 6 hours, starting at midnight\n- `midnight`: every midnight (00:00:00)\n- `week`: every week at sundaynight (sunday, 1 second after 23:59:59 PM)\n- `month`: at the first second of the first day of the month (0:00:00)\n- `3-months`: every start of the quarter: january 1st (0:00:00), april 1st, july 1st, october 1st\n- `year`: every new year at january 1st at 0:00:00",
                    "type": "string"
                  }
                },
                {
                  "name": "price",
                  "required": false,
                  "schema": {
                    "fullComment": "Indexed from frontmatter `price`\n\nTLDR;EUROS\n\nA price is a number indicating the relative cost. Absolute cost is calculated by many other factors\n\nFor now, we're going to keep it simple: 1 `Price` is equal to 1 Eurocent.\n\nLater we can add all kinds of extra conversion:\n\n- currency support\n- king os currency\n- lower cost for poorer people\n\netc...\n\nFirst we need to start making sales before we can add such complexity.\n\n",
                    "type": "number"
                  }
                },
                {
                  "name": "classification",
                  "required": false,
                  "schema": {
                    "enum": [
                      "wise",
                      "dumb",
                      "smart",
                      "genius",
                      "react-with-native",
                      "cli",
                      "test"
                    ],
                    "fullComment": "- `react`: The core library that should always be used that wraps react and react native.\n\n- `dumb`: Presentational components that only care about how things look, and have no idea about the type of information that they will contain (**data-agnostic**), nor their context they're used in.\n\n- `smart`: Presentational components that may contain getters and setters for global state. This means they're still easy enough to set up, but\n\n- `wise`: stateful components that use the backend as well to do things. for example, `simplified-schema-form`\n\n- `genius`: blocks of components that have certain functionality. Example: `file-writer` or `crud`",
                    "type": "string"
                  }
                },
                {
                  "name": "operationName",
                  "required": true,
                  "schema": {
                    "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "null"
                  }
                },
                {
                  "name": "projectRelativePath",
                  "required": true,
                  "schema": {
                    "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "string"
                  }
                },
                {
                  "name": "operationRelativePath",
                  "required": false,
                  "schema": {
                    "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "string"
                  }
                },
                {
                  "name": "id",
                  "required": true,
                  "schema": {
                    "fullComment": "unique id of the model",
                    "type": "string"
                  }
                },
                {
                  "name": "name",
                  "required": true,
                  "schema": {
                    "fullComment": "name (identifier) of the model",
                    "type": "string"
                  }
                },
                {
                  "name": "slug",
                  "required": true,
                  "schema": {
                    "fullComment": "kebab-case variant of the name",
                    "type": "string"
                  }
                },
                {
                  "name": "operationRelativeTypescriptFilePath",
                  "required": true,
                  "schema": {
                    "fullComment": "relative file path from the operation that this indexed instance is referencing to\n\ne.g. src/general.ts\n\n(no preceding slash)",
                    "type": "string"
                  }
                }
              ],
              "type": "object"
            }
          },
          {
            "name": "authorizations",
            "required": false,
            "schema": {
              "fullComment": "Authorizations accumulated of the person(s), the group(s), and public authorizations.\n\nNB: This contains all authorisations because there may also be model authorisations and file authorisations that are needed IN the function.",
              "nb": "This contains all authorisations because there may also be model authorisations and file authorisations that are needed IN the function.",
              "items": [
                {
                  "schema": {
                    "fullComment": "`Authorization` helps you provide certain access to files, data, functionality, and code. Authorization can be provided custom, or by indexation. The indexation of the codebase and text-files overwrites the custom authorization in the `Group`-model.\n\n## Different authorizations\n\nFor files (ts, md, json, etc...):\n\n- canWriteCreate\n- canWriteUpdate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor db model data subsets:\n\n- canWriteUpdate\n- canWriteCreate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor functions:\n\n- canExecute\n\nFor functions, interfaces, variables:\n\n- canRead (reading docs only. for source, you need to provide the file auth)\n- canSearch (only search index)",
                    "properties": [
                      {
                        "name": "isProjectWide",
                        "required": false,
                        "schema": {
                          "fullComment": "If true, this authorization is project-wide and applies to everything",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "authorizedOperationName",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to the whole operation",
                          "type": "string"
                        }
                      },
                      {
                        "name": "tsFunctionId",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to this function\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "tsVariableId",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to this variable\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "tsInterfaceId",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to this interface\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "datasetId",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to this dataset\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "authorizedProjectRelativePath",
                        "required": false,
                        "schema": {
                          "fullComment": "If selected, the authorization will apply to everything in this folder or to this specific file",
                          "type": "string"
                        }
                      },
                      {
                        "name": "canExecute",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "canWriteCreate",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "canWriteUpdate",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "canWriteDelete",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "canRead",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "canSearch",
                        "required": false,
                        "schema": {
                          "type": "boolean"
                        }
                      }
                    ],
                    "type": "object"
                  },
                  "name": "Authorization"
                }
              ],
              "type": "array"
            }
          },
          {
            "name": "device",
            "required": true,
            "schema": {
              "fullComment": "Device from authToken\n\nA Device that accesses any King OS api.\n\nA device can be connected to a person. A person can have multiple `Device`s.\n\nA Device does not necissarily have King OS installed themselves, they can also be a visitor to another King OS app of someone else.",
              "properties": [
                {
                  "name": "ip",
                  "required": true,
                  "schema": {
                    "fullComment": "The ip of the device. Can be a local IP or remote IP.\n\nNB: Port is not included",
                    "nb": "Port is not included",
                    "type": "string"
                  }
                },
                {
                  "name": "city",
                  "required": false,
                  "schema": {
                    "type": "string"
                  }
                },
                {
                  "name": "position",
                  "required": false,
                  "schema": {
                    "fullComment": "",
                    "properties": [
                      {
                        "name": "latitude",
                        "required": true,
                        "schema": {
                          "type": "number"
                        }
                      },
                      {
                        "name": "longitude",
                        "required": true,
                        "schema": {
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "positionRadiusKm",
                  "required": false,
                  "schema": {
                    "type": "number"
                  }
                },
                {
                  "name": "country",
                  "required": false,
                  "schema": {
                    "type": "string"
                  }
                },
                {
                  "name": "region",
                  "required": false,
                  "schema": {
                    "type": "string"
                  }
                },
                {
                  "name": "timezone",
                  "required": false,
                  "schema": {
                    "type": "string"
                  }
                },
                {
                  "name": "createdAt",
                  "required": true,
                  "schema": {
                    "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                    "type": "number"
                  }
                },
                {
                  "name": "updatedAt",
                  "required": true,
                  "schema": {
                    "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                    "type": "number"
                  }
                },
                {
                  "name": "deletedAt",
                  "required": true,
                  "schema": {
                    "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                    "type": "number"
                  }
                },
                {
                  "name": "createdFirstAt",
                  "required": true,
                  "schema": {
                    "fullComment": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n\nTime\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                    "type": "number"
                  }
                },
                {
                  "name": "operationName",
                  "required": true,
                  "schema": {
                    "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "null"
                  }
                },
                {
                  "name": "projectRelativePath",
                  "required": true,
                  "schema": {
                    "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "string"
                  }
                },
                {
                  "name": "operationRelativePath",
                  "required": false,
                  "schema": {
                    "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                    "type": "string"
                  }
                },
                {
                  "name": "id",
                  "required": true,
                  "schema": {
                    "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                    "type": "string"
                  }
                },
                {
                  "name": "categoryStackCalculated",
                  "required": false,
                  "schema": {
                    "fullComment": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!\n\nTaken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
                    "nb": "Changing this value when updating/upserting, changes where the item is located!",
                    "items": [
                      {
                        "schema": {
                          "type": "string"
                        },
                        "name": null
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "authToken",
                  "required": true,
                  "schema": {
                    "fullComment": "AuthToken is used to identify a device. Unique identifier that is saved in the devices browser/app.\n\nIf the authToken is the same, we can be sure that the device is matched, even if the IP is different.",
                    "type": "string"
                  }
                },
                {
                  "name": "userAgent",
                  "required": true,
                  "schema": {
                    "fullComment": "Parsed User Agent header.\n\nNOT used to identify the device, since the device can already be connected to a person!\n\n",
                    "properties": [
                      {
                        "name": "ua",
                        "required": true,
                        "schema": {
                          "type": "string"
                        }
                      },
                      {
                        "name": "browser",
                        "required": true,
                        "schema": {
                          "fullComment": "NB: copied from ua-parser-js ^1.0.32 because they weren't indexed",
                          "nb": "copied from ua-parser-js ^1.0.32 because they weren't indexed",
                          "properties": [
                            {
                              "name": "name",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible values : Amaya, Android Browser, Arora, Avant, Baidu, Blazer, Bolt, Camino, Chimera, Chrome, Chromium, Comodo Dragon, Conkeror, Dillo, Dolphin, Doris, Edge, Epiphany, Fennec, Firebird, Firefox, Flock, GoBrowser, iCab, ICE Browser, IceApe, IceCat, IceDragon, Iceweasel, IE [Mobile], Iron, Jasmine, K-Meleon, Konqueror, Kindle, Links, Lunascape, Lynx, Maemo, Maxthon, Midori, Minimo, MIUI Browser, [Mobile] Safari, Mosaic, Mozilla, Netfront, Netscape, NetSurf, Nokia, OmniWeb, Opera [Mini/Mobi/Tablet], Phoenix, Polaris, QQBrowser, RockMelt, Silk, Skyfire, SeaMonkey, SlimBrowser, Swiftfox, Tizen, UCBrowser, Vivaldi, w3m, Yandex",
                                "type": "string"
                              }
                            },
                            {
                              "name": "version",
                              "required": false,
                              "schema": {
                                "fullComment": "Determined dynamically",
                                "type": "string"
                              }
                            },
                            {
                              "name": "major",
                              "required": false,
                              "schema": {
                                "fullComment": "Determined dynamically",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "device",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "model",
                              "required": false,
                              "schema": {
                                "fullComment": "Determined dynamically",
                                "type": "string"
                              }
                            },
                            {
                              "name": "type",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible type: console, mobile, tablet, smarttv, wearable, embedded",
                                "type": "string"
                              }
                            },
                            {
                              "name": "vendor",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible vendor: Acer, Alcatel, Amazon, Apple, Archos, Asus, BenQ, BlackBerry, Dell, GeeksPhone, Google, HP, HTC, Huawei, Jolla, Lenovo, LG, Meizu, Microsoft, Motorola, Nexian, Nintendo, Nokia, Nvidia, Ouya, Palm, Panasonic, Polytron, RIM, Samsung, Sharp, Siemens, Sony-Ericsson, Sprint, Xbox, ZTE",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "engine",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "name",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible name: Amaya, EdgeHTML, Gecko, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto, Tasman, Trident, w3m, WebKit",
                                "type": "string"
                              }
                            },
                            {
                              "name": "version",
                              "required": false,
                              "schema": {
                                "fullComment": "Determined dynamically",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "os",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "name",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible 'os.name' AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, CentOS, Chromium OS, Contiki, Fedora, Firefox OS, FreeBSD, Debian, DragonFly, Gentoo, GNU, Haiku, Hurd, iOS, Joli, Linpus, Linux, Mac OS, Mageia, Mandriva, MeeGo, Minix, Mint, Morph OS, NetBSD, Nintendo, OpenBSD, OpenVMS, OS/2, Palm, PCLinuxOS, Plan9, Playstation, QNX, RedHat, RIM Tablet OS, RISC OS, Sailfish, Series40, Slackware, Solaris, SUSE, Symbian, Tizen, Ubuntu, UNIX, VectorLinux, WebOS, Windows [Phone/Mobile], Zenwalk",
                                "type": "string"
                              }
                            },
                            {
                              "name": "version",
                              "required": false,
                              "schema": {
                                "fullComment": "Determined dynamically",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "cpu",
                        "required": true,
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "architecture",
                              "required": false,
                              "schema": {
                                "fullComment": "Possible architecture:  68k, amd64, arm, arm64, avr, ia32, ia64, irix, irix64, mips, mips64, pa-risc,  ppc, sparc, sparc64",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "userAgentString",
                  "required": true,
                  "schema": {
                    "fullComment": "Raw `User-Agent` header.\n\nNOT used to identify the device, since the device can already be connected to a person!",
                    "type": "string"
                  }
                },
                {
                  "name": "name",
                  "required": true,
                  "schema": {
                    "fullComment": "Name of the device, calculated based on metadata like location, os, and ip\n\nCan be edited by the user",
                    "type": "string"
                  }
                },
                {
                  "name": "previousIps",
                  "required": true,
                  "schema": {
                    "fullComment": "the root IPInfo is from the latest IP the device had. All previous IPs are added to this array",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "Information that is inferred from an IP",
                          "properties": [
                            {
                              "name": "ip",
                              "required": true,
                              "schema": {
                                "fullComment": "The ip of the device. Can be a local IP or remote IP.\n\nNB: Port is not included",
                                "nb": "Port is not included",
                                "type": "string"
                              }
                            },
                            {
                              "name": "city",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "position",
                              "required": false,
                              "schema": {
                                "fullComment": "",
                                "properties": [
                                  {
                                    "name": "latitude",
                                    "required": true,
                                    "schema": {
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "longitude",
                                    "required": true,
                                    "schema": {
                                      "type": "number"
                                    }
                                  }
                                ],
                                "type": "object"
                              }
                            },
                            {
                              "name": "positionRadiusKm",
                              "required": false,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "country",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "region",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "timezone",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        },
                        "name": "IPInfo"
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "origins",
                  "required": true,
                  "schema": {
                    "fullComment": "Domains the Device has visited\n\nThe Origin request header indicates the origin (scheme, hostname, and port) that caused the request",
                    "items": [
                      {
                        "schema": {
                          "type": "string"
                        },
                        "name": null
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "hasPapi",
                  "required": false,
                  "schema": {
                    "fullComment": "Is set to true if the devices IP is pinged and seems to have something that resembles a King OS PAPI.",
                    "type": "boolean"
                  }
                },
                {
                  "name": "isOnlineCalculated",
                  "required": false,
                  "schema": {
                    "fullComment": "Returning `true` or `false` indicating whether or not the IP is giving a response",
                    "type": "boolean"
                  }
                },
                {
                  "name": "lastOnlineAt",
                  "required": true,
                  "schema": {
                    "fullComment": "Whenever the peer is online, this should update",
                    "type": "number"
                  }
                },
                {
                  "name": "isLocalIpCalculated",
                  "required": false,
                  "schema": {
                    "fullComment": "if true, the above IP is a local one, meaning it cannot be accessed from outside of this network\n\nThis is easy to determine: local IP's must start with \"192.168\"",
                    "type": "boolean"
                  }
                },
                {
                  "name": "isFavorite",
                  "required": false,
                  "schema": {
                    "fullComment": "if `true`, this device will show on top",
                    "type": "boolean"
                  }
                },
                {
                  "name": "isPrivate",
                  "required": false,
                  "schema": {
                    "fullComment": "If true, this peer should not be shared",
                    "type": "boolean"
                  }
                },
                {
                  "name": "lastSyncDatabaseAtObject",
                  "required": true,
                  "schema": {
                    "fullComment": "last sync of any model\n\nUseful for example for a p2p messaging",
                    "properties": [],
                    "type": "object"
                  }
                },
                {
                  "name": "personIds",
                  "required": false,
                  "schema": {
                    "fullComment": "If the device is authenticated, this should be set.\n\nCan be unset by the person",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        },
                        "name": "Id"
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "currentPersonId",
                  "required": false,
                  "schema": {
                    "fullComment": "A device can switch between persons, by changing this value\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                    "type": "string"
                  }
                },
                {
                  "name": "currentPersonCalculated",
                  "required": false,
                  "schema": {
                    "fullComment": "If you have a currentPersonId, it is calculated and provided by selecting it from the persons array\n\nFor now, only provided by functioncontext\n\nModel to describe a human person. This model gathers and stores all persons around the world, except for yourself. Kind of a user-like model...\n\n\nThe data inside this model is coming from the `Person` itself but also from the owner of the OS server. It should be possible for the person to automatically push information into any of their instances on any server, but the OS owner can augment this.\n\nNB: This is a `DefaultModelType`, which means name and slug need not to be unique, but it is highly preferred.",
                    "nb": "This is a `DefaultModelType`, which means name and slug need not to be unique, but it is highly preferred.",
                    "properties": [
                      {
                        "name": "createdAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "updatedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "deletedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "createdFirstAt",
                        "required": true,
                        "schema": {
                          "fullComment": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n\nTime\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "operationName",
                        "required": true,
                        "schema": {
                          "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "null"
                        }
                      },
                      {
                        "name": "projectRelativePath",
                        "required": true,
                        "schema": {
                          "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "string"
                        }
                      },
                      {
                        "name": "operationRelativePath",
                        "required": false,
                        "schema": {
                          "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "string"
                        }
                      },
                      {
                        "name": "id",
                        "required": true,
                        "schema": {
                          "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "categoryStackCalculated",
                        "required": false,
                        "schema": {
                          "fullComment": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!\n\nTaken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
                          "nb": "Changing this value when updating/upserting, changes where the item is located!",
                          "items": [
                            {
                              "schema": {
                                "type": "string"
                              },
                              "name": null
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "name",
                        "required": true,
                        "schema": {
                          "type": "string"
                        }
                      },
                      {
                        "name": "slug",
                        "required": true,
                        "schema": {
                          "type": "string"
                        }
                      },
                      {
                        "name": "pictureImage",
                        "required": false,
                        "schema": {
                          "fullComment": "Part of the asset that should be sent to the backend. The rest should frontend-only\n\nSome values are stored, some are not",
                          "properties": [
                            {
                              "name": "alt",
                              "required": false,
                              "schema": {
                                "fullComment": "Stored value\n\nAlt text for the asset",
                                "type": "string"
                              }
                            },
                            {
                              "name": "relativePath",
                              "required": false,
                              "schema": {
                                "fullComment": "Stored value\n\nRelative path, relative to the location the asset is defined in.\n\nOnly available if the asset was already processed by a backend. Before backend processing, only `temporaryDestination` is available.\n\nChanging the `relativePath` shouldn't do anything, it can only be changed by backend processing by giving a new `temporaryDestination`, or by changing the `name`.",
                                "type": "string"
                              }
                            },
                            {
                              "name": "name",
                              "required": false,
                              "schema": {
                                "fullComment": "Not stored\n\nNot given by the backend data, but can be SENT to the backend.\n\nShould not be stored, but if you change this value and send it to the backend, it should rename the file and thus the relativePath stored should change.\n\nNB: I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!",
                                "nb": "I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!",
                                "type": "string"
                              }
                            },
                            {
                              "name": "temporaryDestination",
                              "required": false,
                              "schema": {
                                "fullComment": "Not stored\n\nFilename after uploading in the temporary folder. should still be moved to its final location\n\nOnly available straight after uploading. After the function processes the asset, this is removed and a `relativePath` is created.",
                                "type": "string"
                              }
                            },
                            {
                              "name": "projectRelativeReferencingFilePath",
                              "required": false,
                              "schema": {
                                "fullComment": "Not stored\n\nNeeds to be there before calling `processAsset`. Should be augmented to the backendAsset in the frontend, before sending it to the backend.\n\nLocation of the place where the asset is referenced\n\n- markdown file (or folder where it is located)\n- typescript file (or folder where it is located)\n- database file (or folder where it is located)",
                                "type": "string"
                              }
                            },
                            {
                              "name": "modelName",
                              "required": false,
                              "schema": {
                                "fullComment": "Not stored\n\nNeeds to be there before calling `processAsset`. Should be augmented to the backendAsset in the frontend, before sending it to the backend.\n\nModel that the asset is related to",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        }
                      },
                      {
                        "name": "interestSlugs",
                        "required": false,
                        "schema": {
                          "fullComment": "slugs of interest categories that this person should be notified about.\n\nSince this is a hierarchical model, parent interests will ensure all children are also applied.",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                                "type": "string"
                              },
                              "name": "Slug"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "media",
                        "required": false,
                        "schema": {
                          "fullComment": "Media that is attached to this person.\n\nNB: not used to authenticate! Can be filled in by King OS, might be erroneous",
                          "nb": "not used to authenticate! Can be filled in by King OS, might be erroneous",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl",
                                "properties": [
                                  {
                                    "name": "platformSlug",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "medium where the person is a user\n\nuse this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "path",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "used to find the user on the platform",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "isPremium",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "(if available) whether or not the user has a premium account",
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "tagline",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "(if available) a tagline for the user of the platform",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "bio",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "(if available) a bio for the user of the platform",
                                      "type": "string"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "PersonSocialMedia"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "preferredContactMedium",
                        "required": false,
                        "schema": {
                          "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "dataEntries",
                        "required": false,
                        "schema": {
                          "items": [
                            {
                              "schema": {
                                "fullComment": "key value data storage model for information about a person\n\n- the filename must identify the person this is about (`personSlug`)\n- the categories are the different people and the person information categories\n- the keys are the person information datapoints\n- the values are the values of the datapoints that you stored about this user\n\nExample:\n\nthe file `person-information-values/abraham-lincoln.md` could contain something like this:\n\n```md # life born: 11-01-1777 died: 20-12-1812\n\n# identification firstName: Abraham lastName: Lincoln ```\n\nNB: It's not going to be easy to keep this model in sync with the model it relies on!\n\nTODO: figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`",
                                "todo": "figure out if this kan be a `KeyValueMarkdownModelType` or `MarkdownModelType`",
                                "nb": "It's not going to be easy to keep this model in sync with the model it relies on!",
                                "properties": [
                                  {
                                    "name": "createdAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "updatedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "deletedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "createdFirstAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n\nTime\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "operationName",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "null"
                                    }
                                  },
                                  {
                                    "name": "projectRelativePath",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "operationRelativePath",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "id",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "categoryStackCalculated",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!\n\nTaken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
                                      "nb": "Changing this value when updating/upserting, changes where the item is located!",
                                      "items": [
                                        {
                                          "schema": {
                                            "type": "string"
                                          },
                                          "name": null
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  },
                                  {
                                    "name": "personId",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "personInformationSlug",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "value",
                                    "required": true,
                                    "schema": {
                                      "type": "string"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "PersonInformationValue"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "devicesCalculated",
                        "required": false,
                        "schema": {
                          "fullComment": "Devices can be attached to a person by looking in the device model and finding the devices that refer to this person\n\nAmong other things, this can be used to determine the `Person` location",
                          "items": [
                            {
                              "schema": {
                                "circularRefName": "Device",
                                "properties": [],
                                "type": "object"
                              },
                              "name": "Device"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "authenticationMethods",
                        "required": true,
                        "schema": {
                          "fullComment": "Methods that can be used to identify yourself as being this user\n\nShould be set up by the user either when registering, or in settings, to provide more methods.\n\nNB: It's important to note that a `Person` should not be able to add credentials that are already added by another person. This means that, when adding such a method, all `Person`s need to be searched!",
                          "nb": "It's important to note that a `Person` should not be able to add credentials that are already added by another person. This means that, when adding such a method, all `Person`s need to be searched!",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "",
                                "properties": [
                                  {
                                    "name": "method",
                                    "required": true,
                                    "schema": {
                                      "enum": [
                                        "usernamePassword",
                                        "phoneNumber",
                                        "email",
                                        "apple",
                                        "google",
                                        "facebook",
                                        "twitter",
                                        "linkedin",
                                        "github"
                                      ],
                                      "fullComment": "NB: Not all are supported yet\n\nUsername + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
                                      "nb": "Not all are supported yet",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "handle",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "most of the time, this is a username, but can also be phone number or email or so",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "encryptedCredential",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "This can be a password or token, depending on the method.\n\nIn case of OTP, this isn't required (e.g. for `phoneNumber`)",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "otp",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "one time password code, that will be sent to email or sms (or in the future other ways)",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "isAuthenticated",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "If OTP is not filled in yet, will be false, otherwise true",
                                      "type": "boolean"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "AuthenticationMethod"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "groupSlugs",
                        "required": false,
                        "schema": {
                          "fullComment": "To which groups does this person belong?\n\nThis determines additional authorizations\n\nCan be set on signup, but can always be edited by admin",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                                "type": "string"
                              },
                              "name": "Slug"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "authorizations",
                        "required": false,
                        "schema": {
                          "fullComment": "Which custom authorizations does this `Person` have?",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "`Authorization` helps you provide certain access to files, data, functionality, and code. Authorization can be provided custom, or by indexation. The indexation of the codebase and text-files overwrites the custom authorization in the `Group`-model.\n\n## Different authorizations\n\nFor files (ts, md, json, etc...):\n\n- canWriteCreate\n- canWriteUpdate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor db model data subsets:\n\n- canWriteUpdate\n- canWriteCreate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor functions:\n\n- canExecute\n\nFor functions, interfaces, variables:\n\n- canRead (reading docs only. for source, you need to provide the file auth)\n- canSearch (only search index)",
                                "properties": [
                                  {
                                    "name": "isProjectWide",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If true, this authorization is project-wide and applies to everything",
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "authorizedOperationName",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to the whole operation",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsFunctionId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this function\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsVariableId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this variable\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsInterfaceId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this interface\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "datasetId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this dataset\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "authorizedProjectRelativePath",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to everything in this folder or to this specific file",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "canExecute",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteCreate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteUpdate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteDelete",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canRead",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canSearch",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "Authorization"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "amountAuthenticationMethodsRequired",
                        "required": false,
                        "schema": {
                          "fullComment": "By default, one is enough, but if this is defined, the user needs to use this amount of authentication methods before he/she is authenticated. Must be at least one",
                          "type": "number"
                        }
                      },
                      {
                        "name": "requiredAuthenticationMethods",
                        "required": false,
                        "schema": {
                          "fullComment": "Optionally, the user can setup for themselves which authentication methods they require for themselves to authenticate on another device",
                          "items": [
                            {
                              "schema": {
                                "enum": [
                                  "usernamePassword",
                                  "phoneNumber",
                                  "email",
                                  "apple",
                                  "google",
                                  "facebook",
                                  "twitter",
                                  "linkedin",
                                  "github"
                                ],
                                "fullComment": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
                                "type": "string"
                              },
                              "name": "AuthenticationMethodMethod"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "paymentAuthToken",
                        "required": false,
                        "schema": {
                          "fullComment": "For now this can be a stripe token, stored for this \"customer\". Handy to connect the customer to the Person. Later this can become an array of multiple credentials, for example if you want to add multiple creditcards.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "credit",
                        "required": false,
                        "schema": {
                          "fullComment": "Actions by the `Person` can create changes in the amount of credits\n\nThe exact meaning of the number of credits is determined by the OS settings. Can for example be 1:1 to euro, 1:1 to bitcoin, or a custom credit system. Transferability is also customisable.\n\nInsufficient credit can limit the persons possibilities within the OS\n\n",
                          "type": "number"
                        }
                      }
                    ],
                    "type": "object"
                  }
                },
                {
                  "name": "appOperationsCalculated",
                  "required": false,
                  "schema": {
                    "fullComment": "Calculated all operations that can be exposed as apps. This is taken from `getAllAppOperations` function",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "name",
                              "required": true,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "port",
                              "required": true,
                              "schema": {
                                "type": "number"
                              }
                            },
                            {
                              "name": "description",
                              "required": false,
                              "schema": {
                                "type": "string"
                              }
                            },
                            {
                              "name": "isOnline",
                              "required": false,
                              "schema": {
                                "type": "boolean"
                              }
                            },
                            {
                              "name": "emoji",
                              "required": false,
                              "schema": {
                                "fullComment": "Emoji that should be used as the app icon. Can be calculated from the `OPERATION.md`",
                                "type": "string"
                              }
                            }
                          ],
                          "type": "object"
                        },
                        "name": "AppOperation"
                      }
                    ],
                    "type": "array"
                  }
                },
                {
                  "name": "authenticationMethods",
                  "required": true,
                  "schema": {
                    "fullComment": "If the `Device` is not identified as a person yet, this can be configured to authenticate with different methods. Once it matches to a person, this can be cleared and `personId` can be attached.",
                    "items": [
                      {
                        "schema": {
                          "fullComment": "",
                          "properties": [
                            {
                              "name": "method",
                              "required": true,
                              "schema": {
                                "enum": [
                                  "usernamePassword",
                                  "phoneNumber",
                                  "email",
                                  "apple",
                                  "google",
                                  "facebook",
                                  "twitter",
                                  "linkedin",
                                  "github"
                                ],
                                "fullComment": "NB: Not all are supported yet\n\nUsername + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
                                "nb": "Not all are supported yet",
                                "type": "string"
                              }
                            },
                            {
                              "name": "handle",
                              "required": true,
                              "schema": {
                                "fullComment": "most of the time, this is a username, but can also be phone number or email or so",
                                "type": "string"
                              }
                            },
                            {
                              "name": "encryptedCredential",
                              "required": false,
                              "schema": {
                                "fullComment": "This can be a password or token, depending on the method.\n\nIn case of OTP, this isn't required (e.g. for `phoneNumber`)",
                                "type": "string"
                              }
                            },
                            {
                              "name": "otp",
                              "required": false,
                              "schema": {
                                "fullComment": "one time password code, that will be sent to email or sms (or in the future other ways)",
                                "type": "number"
                              }
                            },
                            {
                              "name": "isAuthenticated",
                              "required": true,
                              "schema": {
                                "fullComment": "If OTP is not filled in yet, will be false, otherwise true",
                                "type": "boolean"
                              }
                            }
                          ],
                          "type": "object"
                        },
                        "name": "AuthenticationMethod"
                      }
                    ],
                    "type": "array"
                  }
                }
              ],
              "type": "object"
            }
          },
          {
            "name": "groups",
            "required": false,
            "schema": {
              "fullComment": "Groups the person(s) of the device belong to",
              "items": [
                {
                  "schema": {
                    "fullComment": "A `Person` is able to be part of one or multiple `Group`s. \n\nA `Device` without `Person` is just part of group `public` and can only access `public` info and features.\n\n`Group`s and individual `Person`s can be given `Authorization`\n\nFunctions that require authorization can have something in this format in their doc-comment:\n\n`[groupName]: x, y, z`\n\nE.g.\n\n```md\n--- manager: canExecute\n--- ```",
                    "properties": [
                      {
                        "name": "slug",
                        "required": true,
                        "schema": {
                          "fullComment": "kebab-case of the name, should be unique\n\nuse this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "name",
                        "required": true,
                        "schema": {
                          "fullComment": "Name of the group (will set slug)\n\nNB: this can be used in functions to specify certain access to groups. It should there fore be unique and you should be careful when changing it!",
                          "nb": "this can be used in functions to specify certain access to groups. It should there fore be unique and you should be careful when changing it!",
                          "type": "string"
                        }
                      },
                      {
                        "name": "language",
                        "required": true,
                        "schema": {
                          "enum": [
                            "english",
                            "dutch",
                            "nepali",
                            "portuguese",
                            "brazilian",
                            "german",
                            "french",
                            "spanish",
                            "italian",
                            "norwegian",
                            "swedish",
                            "danish",
                            "vietnamese",
                            "indonesian",
                            "southAfrican",
                            "tokiPona",
                            "hindi",
                            "mandarin",
                            "arabic",
                            "bengali",
                            "urdu",
                            "japanese",
                            "swahili"
                          ],
                          "fullComment": "all currently supported languages",
                          "type": "string"
                        }
                      },
                      {
                        "name": "createdAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "updatedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "deletedAt",
                        "required": true,
                        "schema": {
                          "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "createdFirstAt",
                        "required": true,
                        "schema": {
                          "fullComment": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n\nTime\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                          "type": "number"
                        }
                      },
                      {
                        "name": "operationName",
                        "required": true,
                        "schema": {
                          "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "null"
                        }
                      },
                      {
                        "name": "projectRelativePath",
                        "required": true,
                        "schema": {
                          "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "string"
                        }
                      },
                      {
                        "name": "operationRelativePath",
                        "required": false,
                        "schema": {
                          "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                          "type": "string"
                        }
                      },
                      {
                        "name": "id",
                        "required": true,
                        "schema": {
                          "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "categoryStackCalculated",
                        "required": false,
                        "schema": {
                          "fullComment": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!\n\nTaken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
                          "nb": "Changing this value when updating/upserting, changes where the item is located!",
                          "items": [
                            {
                              "schema": {
                                "type": "string"
                              },
                              "name": null
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "description",
                        "required": false,
                        "schema": {
                          "type": "string"
                        }
                      },
                      {
                        "name": "customAuthorizations",
                        "required": false,
                        "schema": {
                          "fullComment": "Optionally, provide custom authorization to a group",
                          "items": [
                            {
                              "schema": {
                                "fullComment": "`Authorization` helps you provide certain access to files, data, functionality, and code. Authorization can be provided custom, or by indexation. The indexation of the codebase and text-files overwrites the custom authorization in the `Group`-model.\n\n## Different authorizations\n\nFor files (ts, md, json, etc...):\n\n- canWriteCreate\n- canWriteUpdate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor db model data subsets:\n\n- canWriteUpdate\n- canWriteCreate\n- canWriteDelete\n- canRead\n- canSearch (only search index)\n\nFor functions:\n\n- canExecute\n\nFor functions, interfaces, variables:\n\n- canRead (reading docs only. for source, you need to provide the file auth)\n- canSearch (only search index)",
                                "properties": [
                                  {
                                    "name": "isProjectWide",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If true, this authorization is project-wide and applies to everything",
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "authorizedOperationName",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to the whole operation",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsFunctionId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this function\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsVariableId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this variable\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsInterfaceId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this interface\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "datasetId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this dataset\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "authorizedProjectRelativePath",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to everything in this folder or to this specific file",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "canExecute",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteCreate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteUpdate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteDelete",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canRead",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canSearch",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "Authorization"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "indexedAuthorizationCalculated",
                        "required": false,
                        "schema": {
                          "items": [
                            {
                              "schema": {
                                "fullComment": "Authorization model for indexed authorizations\n\nDon't edit this! If you wish to add authorizations to a group, either edit the code or text-files, or provide custom authorizations to the `Group`.",
                                "properties": [
                                  {
                                    "name": "isProjectWide",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If true, this authorization is project-wide and applies to everything",
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "authorizedOperationName",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to the whole operation",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsFunctionId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this function\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsVariableId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this variable\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "tsInterfaceId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this interface\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "datasetId",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to this dataset\n\nShould be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "authorizedProjectRelativePath",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "If selected, the authorization will apply to everything in this folder or to this specific file",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "canExecute",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteCreate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteUpdate",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canWriteDelete",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canRead",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "canSearch",
                                    "required": false,
                                    "schema": {
                                      "type": "boolean"
                                    }
                                  },
                                  {
                                    "name": "createdAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "updatedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "deletedAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Time\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "createdFirstAt",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "in some cases, data can be created before it was created in our system. In this case, use CreatedFirstAt if this information is important.\n\nTime\n\nTime can be stored in various ways but in my experience it is, again, best to keep it simple and just have one way to store time. I can think about this for hours, but my intuition goes towards using the same format as Date.now() because it is a very small format and is easy to read.\n\nIt is the amount of ms since 1970.\n\nI could argue to store it in seconds since 1970 since there are few applications of doing ms, but maybe we do, and it's just 30% bigger. No problem.\n\nTherefore, let's store all time values in the format Date.now()",
                                      "type": "number"
                                    }
                                  },
                                  {
                                    "name": "operationName",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "name of operation the model belongs to\n\n- calculated value (not stored in database)\n- can be `null` or an actual operationName that it was saved at\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "null"
                                    }
                                  },
                                  {
                                    "name": "projectRelativePath",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "path to dbfile\n\n- calculated value (not stored in database)\n- relatively from the project (without slash at start)\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "operationRelativePath",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "path to db file\n\n- relatively from the operation root folder (without slash at start)\n- calculated value (not stored in database)\n- can be `undefined` if the db file does not belong to an operation\n- can be `undefined` when you are creating an item, because then it can be set for you",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "id",
                                    "required": true,
                                    "schema": {
                                      "fullComment": "Should be an unique string By default, you can use `generateId()` to generate a random string of 16 characters. If you wish, you can also use any other string, as long as you are sure it's unique.\n\n# Background Info\n\nazAZ09 characters are easy to copy and provide 62 characters. the goal of an id is to be unique.\n\nthe advantage of a random id compared to an numeric id starting with 1 with auto increment is that you can set them up decentralised.\n\nthe change of duplicate ids gets bigger once you make them shorter the change of finding an existing id gets bigger once you make them shorter\n\nAn Id with 12 characters would provide 3.22e21 combinations.\n\nWhat is the change of duplicate ids? This depends on the amount of identifyable items in the data What is the change of guessing an id? This depends on speed of a brute force attack and the amount of available datapoints. If you can guess 10000 times per second, you can make 864.000.000 guesses. A billion guesses on a dataset of a billion datapoints yields 3226 correct ids on average.\n\nWhy make an id short? I don't know if there's an important reason.\n\nAll in all, I think we should make ids 24 characters by default. This would make it very easy to store, yet, with more than E42 combinations, make it nearly impossible to get duplication or brute force hits.\n\nAn id would look like this:\n\n``` { \"id\": \"sk2EcW9AkZpksk2EcW9AkZpk\" } ```\n\nLooks good to me! Don't think about it and just keep it simple. We can always migrate later to a bigger amount, but I don't see good reason to keep it smaller than this.",
                                      "type": "string"
                                    }
                                  },
                                  {
                                    "name": "categoryStackCalculated",
                                    "required": false,
                                    "schema": {
                                      "fullComment": "In case of jsonSingle storageMethod, the categoryStack is generated by the location of the file in the db model folder in the db folder.\n\nNB: Changing this value when updating/upserting, changes where the item is located!\n\nTaken from the location in the folder of the db-model.\n\nNB: Changing this value when updating/upserting, changes where the item is located!",
                                      "nb": "Changing this value when updating/upserting, changes where the item is located!",
                                      "items": [
                                        {
                                          "schema": {
                                            "type": "string"
                                          },
                                          "name": null
                                        }
                                      ],
                                      "type": "array"
                                    }
                                  }
                                ],
                                "type": "object"
                              },
                              "name": "AuthorizationModel"
                            }
                          ],
                          "type": "array"
                        }
                      },
                      {
                        "name": "amountAuthenticationMethodsRequired",
                        "required": false,
                        "schema": {
                          "fullComment": "By default, one is enough, but if this is defined, the users in this group need to use this amount of authentication methods before he/she is authenticated. Must be at least one.",
                          "type": "number"
                        }
                      },
                      {
                        "name": "requiredAuthenticationMethods",
                        "required": false,
                        "schema": {
                          "fullComment": "Optionally, you can specify which authentication methods are required for the whole group",
                          "items": [
                            {
                              "schema": {
                                "enum": [
                                  "usernamePassword",
                                  "phoneNumber",
                                  "email",
                                  "apple",
                                  "google",
                                  "facebook",
                                  "twitter",
                                  "linkedin",
                                  "github"
                                ],
                                "fullComment": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
                                "type": "string"
                              },
                              "name": "AuthenticationMethodMethod"
                            }
                          ],
                          "type": "array"
                        }
                      }
                    ],
                    "type": "object"
                  },
                  "name": "Group"
                }
              ],
              "type": "array"
            }
          },
          {
            "name": "hasAuthorization",
            "required": true,
            "schema": {
              "fullComment": "Device has authorization to the function",
              "type": "boolean"
            }
          },
          {
            "name": "authToken",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "serverContext",
            "required": false,
            "schema": {
              "fullComment": "Original context coming from server.js\n\nNB: due to indexation problems the type has been removed. It can be casted to the `Context` type, which you can import from:\n\n`import { Context } from \"server/typings/common\";`",
              "nb": "due to indexation problems the type has been removed. It can be casted to the `Context` type, which you can import from:",
              "properties": [],
              "type": "object"
            }
          }
        ],
        "type": "object"
      },
      "required": true
    },
    {
      "name": "details",
      "schema": {
        "$ref": "#/definitions/PersonProfileDetails"
      },
      "simplifiedSchema": {
        "fullComment": "Things the user can fill in about themselves on their profile",
        "properties": [
          {
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pictureImage",
            "required": false,
            "schema": {
              "fullComment": "Part of the asset that should be sent to the backend. The rest should frontend-only\n\nSome values are stored, some are not",
              "properties": [
                {
                  "name": "alt",
                  "required": false,
                  "schema": {
                    "fullComment": "Stored value\n\nAlt text for the asset",
                    "type": "string"
                  }
                },
                {
                  "name": "relativePath",
                  "required": false,
                  "schema": {
                    "fullComment": "Stored value\n\nRelative path, relative to the location the asset is defined in.\n\nOnly available if the asset was already processed by a backend. Before backend processing, only `temporaryDestination` is available.\n\nChanging the `relativePath` shouldn't do anything, it can only be changed by backend processing by giving a new `temporaryDestination`, or by changing the `name`.",
                    "type": "string"
                  }
                },
                {
                  "name": "name",
                  "required": false,
                  "schema": {
                    "fullComment": "Not stored\n\nNot given by the backend data, but can be SENT to the backend.\n\nShould not be stored, but if you change this value and send it to the backend, it should rename the file and thus the relativePath stored should change.\n\nNB: I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!",
                    "nb": "I'm not sure how to solve having multiple references to a single file. If this occurs, which is hard to prevent if allowing manual editing of data, it may be hard to prevent dead links if someone changes the name of a file that is also refered to in other places. In this case, it would be ideal if all references also would be renamed, but it may be hard to find them. Even if we solve this, it's still possible to get dead links if someone renames the file (or removes it) manually. This should be taken into account, and may not break anything!",
                    "type": "string"
                  }
                },
                {
                  "name": "temporaryDestination",
                  "required": false,
                  "schema": {
                    "fullComment": "Not stored\n\nFilename after uploading in the temporary folder. should still be moved to its final location\n\nOnly available straight after uploading. After the function processes the asset, this is removed and a `relativePath` is created.",
                    "type": "string"
                  }
                },
                {
                  "name": "projectRelativeReferencingFilePath",
                  "required": false,
                  "schema": {
                    "fullComment": "Not stored\n\nNeeds to be there before calling `processAsset`. Should be augmented to the backendAsset in the frontend, before sending it to the backend.\n\nLocation of the place where the asset is referenced\n\n- markdown file (or folder where it is located)\n- typescript file (or folder where it is located)\n- database file (or folder where it is located)",
                    "type": "string"
                  }
                },
                {
                  "name": "modelName",
                  "required": false,
                  "schema": {
                    "fullComment": "Not stored\n\nNeeds to be there before calling `processAsset`. Should be augmented to the backendAsset in the frontend, before sending it to the backend.\n\nModel that the asset is related to",
                    "type": "string"
                  }
                }
              ],
              "type": "object"
            }
          },
          {
            "name": "interestSlugs",
            "required": false,
            "schema": {
              "fullComment": "slugs of interest categories that this person should be notified about.\n\nSince this is a hierarchical model, parent interests will ensure all children are also applied.",
              "items": [
                {
                  "schema": {
                    "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                    "type": "string"
                  },
                  "name": "Slug"
                }
              ],
              "type": "array"
            }
          },
          {
            "name": "media",
            "required": false,
            "schema": {
              "fullComment": "Media that is attached to this person.\n\nNB: not used to authenticate! Can be filled in by King OS, might be erroneous",
              "nb": "not used to authenticate! Can be filled in by King OS, might be erroneous",
              "items": [
                {
                  "schema": {
                    "fullComment": "media (mediums) that a person uses, e.g. linkedin, twitter, whatsapp, sms, calling, and irl",
                    "properties": [
                      {
                        "name": "platformSlug",
                        "required": true,
                        "schema": {
                          "fullComment": "medium where the person is a user\n\nuse this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
                          "type": "string"
                        }
                      },
                      {
                        "name": "path",
                        "required": true,
                        "schema": {
                          "fullComment": "used to find the user on the platform",
                          "type": "string"
                        }
                      },
                      {
                        "name": "isPremium",
                        "required": true,
                        "schema": {
                          "fullComment": "(if available) whether or not the user has a premium account",
                          "type": "boolean"
                        }
                      },
                      {
                        "name": "tagline",
                        "required": false,
                        "schema": {
                          "fullComment": "(if available) a tagline for the user of the platform",
                          "type": "string"
                        }
                      },
                      {
                        "name": "bio",
                        "required": false,
                        "schema": {
                          "fullComment": "(if available) a bio for the user of the platform",
                          "type": "string"
                        }
                      }
                    ],
                    "type": "object"
                  },
                  "name": "PersonSocialMedia"
                }
              ],
              "type": "array"
            }
          },
          {
            "name": "preferredContactMedium",
            "required": false,
            "schema": {
              "fullComment": "use this for any identifier that's not an Id-type. Usually this is a kebab-case version of a written text, but it can also be a file path, for example.",
              "type": "string"
            }
          },
          {
            "name": "amountAuthenticationMethodsRequired",
            "required": false,
            "schema": {
              "fullComment": "By default, one is enough, but if this is defined, the user needs to use this amount of authentication methods before he/she is authenticated. Must be at least one",
              "type": "number"
            }
          },
          {
            "name": "requiredAuthenticationMethods",
            "required": false,
            "schema": {
              "fullComment": "Optionally, the user can setup for themselves which authentication methods they require for themselves to authenticate on another device",
              "items": [
                {
                  "schema": {
                    "enum": [
                      "usernamePassword",
                      "phoneNumber",
                      "email",
                      "apple",
                      "google",
                      "facebook",
                      "twitter",
                      "linkedin",
                      "github"
                    ],
                    "fullComment": "Username + password should be the default\n\nEmail OTP, phone number OTP (sms or call or whatsapp), should be optional 2FA methods\n\nAll others can also act as authentication methods, but the token shouldn't be stored",
                    "type": "string"
                  },
                  "name": "AuthenticationMethodMethod"
                }
              ],
              "type": "array"
            }
          }
        ],
        "type": "object"
      },
      "required": true
    }
  ],
  "description": "",
  "returnType": {
    "rawType": "Promise<{ isSuccessful: boolean; message: string; }>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 3,
  "size": {
    "characters": 878,
    "lines": 31,
    "bytes": 878,
    "bytesPerCharacter": 1,
    "charactersPerLine": 28,
    "linesPerFile": 31,
    "numberOfFiles": 1
  },
  "id": "rohevxplvimyjeozysqmmnzb"
}