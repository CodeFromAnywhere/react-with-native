{
  "createdAt": 1670218557405,
  "updatedAt": 1670218557405,
  "deletedAt": 0,
  "createdFirstAt": 1670218557405,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "getDbModel",
  "slug": "get-db-model",
  "operationRelativeTypescriptFilePath": "src/getDbModel.ts",
  "type": {
    "rawType": "<KInterface extends Extract<keyof import(\"/Users/king/King/operations/tools/generated/sdk-db/build/sdk-db\").DbModels, string>, TDatasetConfig extends import(\"/Users/king/King/operations/tools/types/code-types/build/Dataset\").DatasetConfig>(interfaceName: KInterface | null, datasetConfig?: TDatasetConfig | undefined, search?: string | undefined) => Promise<import(\"/Users/king/King/operations/tools/purpose/codebase-introspection/database/db-recipes/src/getDbModel\").GetDbModelResult<KInterface>>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async <\n  KInterface extends Extract<keyof DbModels, string>,\n  TDatasetConfig extends DatasetConfig\n>(\n  /**\n   * the interfaceName you want to get\n   */\n  interfaceName: KInterface | null,\n  /**\n   * optionally, provide a configuration\n   */\n  datasetConfig?: TDatasetConfig,\n\n  /**\n   * This search should be done on the deepest JSON value's of the whole thing. The purpose is not limiting the content to user, but rather just a nice user experience where one can quickly search\n   */\n  search?: string\n): Promise<GetDbModelResult<KInterface>> => {\n  if (!interfaceName) {\n    return { data: [], hasMore: false, message: \"No interfaceName posted\" };\n  }\n\n  const data = await db.get(interfaceName);\n\n  // NB: slice the data, if needed\n  const slicedStartData = data.slice(datasetConfig?.startFromIndex);\n\n  const slicedLimitData = datasetConfig?.maxRows\n    ? slicedStartData.slice(0, datasetConfig.maxRows)\n    : slicedStartData;\n\n  const hasMore = slicedLimitData.length < slicedStartData.length;\n\n  // NB: filter the sliced data, if needed\n  const filteredData = datasetConfig?.filter?.length\n    ? datasetConfig?.filter.reduce((filteredData, datasetFilter) => {\n        const newFilteredData: DbModels[KInterface][] = filteredData.filter(\n          (item) => {\n            const key = datasetFilter.objectParameterKey as keyof typeof item;\n\n            const value = item[key];\n\n            if (datasetFilter.operator === \"equal\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            if (datasetFilter.operator === \"notEqual\") {\n              return String(value) === datasetFilter.value;\n            }\n\n            const lowercaseValue = String(value).toLowerCase();\n            const lowercaseDatasetValue = String(\n              datasetFilter.value\n            ).toLowerCase();\n\n            if (datasetFilter.operator === \"endsWith\") {\n              return lowercaseValue.endsWith(lowercaseDatasetValue);\n            }\n            if (datasetFilter.operator === \"startsWith\") {\n              return lowercaseValue.startsWith(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includes\") {\n              return lowercaseValue.includes(lowercaseDatasetValue);\n            }\n\n            if (datasetFilter.operator === \"includesLetters\") {\n              return hasAllLetters(lowercaseValue, lowercaseDatasetValue);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) > Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThan\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) < Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"greaterThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) >= Number(datasetFilter.value);\n            }\n\n            if (\n              datasetFilter.operator === \"lessThanOrEqual\" &&\n              datasetFilter.value !== null &&\n              datasetFilter.value !== undefined\n            ) {\n              return Number(value) <= Number(datasetFilter.value);\n            }\n\n            return false;\n          }\n        );\n\n        return newFilteredData;\n      }, slicedLimitData)\n    : slicedLimitData;\n\n  // NB: sort the filtered data, if needed\n\n  const sortedData = datasetConfig?.sort\n    ? datasetConfig.sort.reduce((sortedData, datasetSort) => {\n        const newSortedData: DbModels[KInterface][] = sortedData.sort(\n          (a, b) => {\n            // @ts-ignore\n            const valueA = a[datasetSort.objectParameterKey];\n            // @ts-ignore\n            const valueB = b[datasetSort.objectParameterKey];\n\n            const directionMultiplier =\n              datasetSort.sortDirection === \"ascending\" ? 1 : -1;\n\n            return Number(valueA) < Number(valueB)\n              ? directionMultiplier\n              : directionMultiplier * -1;\n          }\n        );\n\n        return newSortedData;\n      }, filteredData)\n    : filteredData;\n\n  const searchedData =\n    search && search.length > 0\n      ? sortedData.filter((item) => {\n          const searchable = Object.values(item)\n            .map((value) => JSON.stringify(value))\n            .join(\",\")\n            .toLowerCase();\n\n          return searchable.includes(search.toLowerCase());\n        })\n      : sortedData;\n\n  const subsetData = datasetConfig?.objectParameterKeys?.length\n    ? searchedData.map(\n        (item) =>\n          getSubsetFromObject(\n            item,\n            datasetConfig.objectParameterKeys! as readonly (keyof DbModels[KInterface])[]\n          ) as DatasetItem<DbModels[KInterface], TDatasetConfig>\n      )\n    : searchedData;\n\n  const ignoredData = datasetConfig?.ignoreObjectParameterKeys?.length\n    ? subsetData.map((item) => {\n        return removeOptionalKeysFromObjectStrings(\n          item as { [key: string]: any },\n          datasetConfig.ignoreObjectParameterKeys!\n        );\n      })\n    : subsetData;\n\n  const finalData = ignoredData as DbModels[KInterface][];\n\n  return {\n    datasetConfig,\n    data: finalData,\n    hasMore,\n  };\n}",
  "description": "gets all instances of an db data interface from the db in a typesafe way",
  "id": "zxjwmwrxfwdptornvgjcahai"
}