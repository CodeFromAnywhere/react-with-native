[
  {
    "createdAt": 1670590327955,
    "updatedAt": 1670590327955,
    "deletedAt": 0,
    "createdFirstAt": 1670590327955,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/util.ts",
    "comment": "get the ImportSpecifier(s) of with a certain name.",
    "rawStatement": "export const getImportSpecifiersWithNames = (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n};",
    "parameters": {},
    "types": [],
    "firstLine": 60,
    "lastLine": 62,
    "id": "buustuaghpktcrtupehwkhxw"
  },
  {
    "createdAt": 1670590327955,
    "updatedAt": 1670590327955,
    "deletedAt": 0,
    "createdFirstAt": 1670590327955,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/util.ts",
    "comment": "",
    "rawStatement": "export const getImportSpecifiersWithNames = (\n  sourceFile: SourceFile,\n  names: string[]\n) => {\n  return sourceFile\n    .getImportDeclarations()\n    .map((x) => x.getNamedImports())\n    .flat()\n    .filter((x) => names.includes(x.getName()));\n};",
    "parameters": {},
    "types": [],
    "firstLine": 72,
    "lastLine": 72,
    "id": "mcybwgzinlrzmkjwplcntdzc"
  },
  {
    "createdAt": 1670590327955,
    "updatedAt": 1670590327955,
    "deletedAt": 0,
    "createdFirstAt": 1670590327955,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/util.ts",
    "comment": "gets type of a symbol and if the type has a generic, without recursing.",
    "rawStatement": "export const getDefaultSymbolType = (\n  symbol: Symbol,\n  debug?: boolean\n): TypeSpecifier => {\n  if (debug) {\n    console.log({\n      kinds: symbol\n        .getDeclarations()\n        .map((x) => ({ kind: x.getKindName(), name: x.getText() })),\n    });\n  }\n  const symbolTypeDeclarations = getSymbolTypeDeclarations(symbol);\n\n  const type = symbolTypeDeclarations.length > 0 ? \"type\" : \"value\";\n  /**\n   * checks whether the symbol contains a type declaration which has a generic parameter\n   */\n  const hasGeneric =\n    type === \"type\"\n      ? !!symbolTypeDeclarations.find(\n          // NB: type parameters gets the generics\n          (declaration) => getHasGeneric(declaration)\n        )\n      : undefined;\n\n  return { type, hasGeneric };\n};",
    "parameters": {},
    "types": [],
    "firstLine": 74,
    "lastLine": 76,
    "id": "jtvoxwgqgsbjfymhrldonwys"
  },
  {
    "createdAt": 1670590327955,
    "updatedAt": 1670590327955,
    "deletedAt": 0,
    "createdFirstAt": 1670590327955,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/util.ts",
    "comment": "gets type of exportSymbols. recurses if it's an exportsymbol\n\nTODO: NB: exports that come from a destructured initialiser aren't found! fix it",
    "rawStatement": "export const getExportSymbolTypeRecursive = (\n  symbol: Symbol,\n  sourceFile: SourceFile,\n  debug?: boolean\n): TypeSpecifier | undefined => {\n  const exportSpecifierNames = getExportSpecifierNames(symbol);\n\n  if (debug) console.log(exportSpecifierNames);\n\n  if (exportSpecifierNames.length > 0) {\n    // get the ImportSpecifier of this ExportSpecifier, and if one exists, recurse this function on it.\n\n    const importSpecifiers = getImportSpecifiersWithNames(\n      sourceFile,\n      exportSpecifierNames\n    );\n\n    if (importSpecifiers.length > 1) {\n      // NB: warn if there is more than one as that would be strange\n\n      log(\n        `More than one importsSpecifiers with that name: ${exportSpecifierNames.join(\n          \",\"\n        )} (imports: ${importSpecifiers\n          .map((x) => x.getName())\n          .join(\",\")})... file: ${sourceFile.getFilePath()}`,\n        {\n          type: \"warning\",\n        }\n      );\n    }\n\n    if (importSpecifiers.length > 0) {\n      return getTypeFromImportSpecifierRecursive(importSpecifiers[0], debug);\n    }\n\n    /* REmoved this.... seems that this will make it never do the default one\n      else {\n        if (debug) {\n          console.log(\n            \"Weird, we couldn't find the importspecifier for exportSpecifiers\"\n          );\n        }\n        return { type: undefined };\n      }\n      */\n  }\n\n  return getDefaultSymbolType(symbol, debug);\n};",
    "parameters": {},
    "types": [
      "todo"
    ],
    "firstLine": 105,
    "lastLine": 109,
    "id": "yayjkundiaiorizexzfibbfy"
  },
  {
    "createdAt": 1670590327956,
    "updatedAt": 1670590327956,
    "deletedAt": 0,
    "createdFirstAt": 1670590327956,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/util.ts",
    "comment": "Recursive function that gets the type specifier from an import specifier",
    "rawStatement": "export const getTypeFromImportSpecifierRecursive = (\n  importSpecifier: ImportSpecifier,\n  debug?: boolean,\n  /**\n   * Files it was already in (to prevent infinite loops)\n   */\n  fileStack?: string[]\n): TypeSpecifier | undefined => {\n  // NB: find the file where the import is defined\n\n  try {\n    const fileOfExport = importSpecifier\n      .getImportDeclaration()\n      .getModuleSpecifierSourceFile();\n\n    // NB: without the module source we can't know the type of this importspecifier\n    if (!fileOfExport) return;\n    const filePath = fileOfExport.getFilePath();\n    if (!filePath) return;\n\n    const realFileStack = fileStack || [];\n\n    if (realFileStack.includes(filePath)) {\n      console.log(\"Infinite loop found, returning...\", { filePath, fileStack });\n      return;\n    }\n\n    const newFileStack = realFileStack.concat(filePath);\n\n    // NB: in the source, find all exported stuff\n    const exportSymbols: Symbol[] = fileOfExport.getExportSymbols();\n\n    // NB: find the export with the same name as the import\n    const importedSymbol = exportSymbols.find(\n      (x) => x.getName() === importSpecifier.getName()\n    );\n\n    // NB: if the source doesn't contain any export with that name, we can't know its type\n    if (!importedSymbol) return;\n\n    /**\n     * NB: all ExportSpecifiers don't have a more specific SyntaxKind because they are imported.\n     * If there are any ExportSpecifiers with a matching ImportSpecifier, recurse on that!\n     */\n    const exportSpecifierNames = getExportSpecifierNames(importedSymbol);\n\n    if (exportSpecifierNames.length > 0) {\n      const importSpecifiers = getImportSpecifiersWithNames(\n        fileOfExport,\n        exportSpecifierNames\n      );\n\n      if (importSpecifiers.length > 1) {\n        // NB: warn if there is more than one as that would be strange\n\n        log(\"More than one importsSpecifiers with that name\", {\n          type: \"warning\",\n        });\n      }\n\n      if (importSpecifiers.length > 0 && newFileStack.length < 10) {\n        // console.log(`recursing`, { newFileStack, filePath });\n\n        // NB: recursion!\n        const first = importSpecifiers[0];\n        return getTypeFromImportSpecifierRecursive(first, debug, newFileStack);\n      } else {\n        if (debug)\n          console.log(\"Weird, no importspecifiers found for exportSpecifier!!\");\n        return;\n      }\n    }\n\n    // console.log({\n    //   fileOfExport: fileOfExport?.getFilePath(),\n    //   exportSymbols: exportSymbols?.map((x) => x.getName()),\n    //   importSpecifier: importSpecifier.getName(),\n    //   importedSymbol: importedSymbol?.getName(),\n    //   name: importSpecifier.getName(),\n    // });\n\n    return getDefaultSymbolType(importedSymbol, debug);\n  } catch (e) {\n    console.log(\"failed\");\n    return;\n  }\n};",
    "parameters": {},
    "types": [],
    "firstLine": 161,
    "lastLine": 163,
    "id": "vyrqiukfxcaqhcdcryldtnhs"
  }
]