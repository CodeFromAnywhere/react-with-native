{
  "createdAt": 1668150640388,
  "updatedAt": 1668150640388,
  "deletedAt": 0,
  "createdFirstAt": 1668150640388,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "getImportsExports",
  "slug": "get-imports-exports",
  "operationRelativeTypescriptFilePath": "src/getImportsExports.ts",
  "type": {
    "rawType": "({ sourceFiles, debug, manualProjectRoot, }: { sourceFiles: import(\"/Users/king/King/operations/node_modules/ts-morph/lib/ts-morph\").SourceFile[]; debug?: boolean | undefined; manualProjectRoot?: string | undefined; }) => Promise<import(\"/Users/king/King/operations/tools/typescript/get-imports-exports/src/util\").ImportsAndExports | undefined>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async ({\n  sourceFiles,\n  debug,\n  manualProjectRoot,\n}: {\n  /**\n   * if given, only these sourcefiles are used, otherwise takes all source files from project.\n   */\n  sourceFiles: SourceFile[];\n  debug?: boolean;\n  manualProjectRoot?: string;\n}): Promise<ImportsAndExports | undefined> => {\n  if (sourceFiles.length === 0) {\n    log(\"No source files provided\", { type: \"warning\" });\n    return;\n  }\n\n  const allOperationsPaths = await exploreOperationFolders({\n    basePath: manualProjectRoot,\n  });\n  const allOperations = allOperationsPaths.map(getLastFolder);\n  const firstFilePath = sourceFiles[0].getFilePath();\n  if (!firstFilePath) return;\n\n  const operationBasePath = findOperationBasePath(firstFilePath);\n  if (!operationBasePath) return;\n\n  const packageJson = await readJsonFile<PackageJson>(\n    path.join(operationBasePath, \"package.json\")\n  );\n\n  if (!packageJson) {\n    log(\"PackageJson could not be found\", { type: \"error\" });\n    return;\n  }\n\n  const allTsExports = (\n    await mapMany(\n      sourceFiles,\n      async (sourceFile) => {\n        const absoluteFilePath = sourceFile.getFilePath();\n        if (!absoluteFilePath) return;\n\n        const operationRelativeTypescriptFilePath = makeRelative(\n          absoluteFilePath,\n          operationBasePath\n        );\n\n        const exportSymbols: Symbol[] = sourceFile.getExportSymbols();\n        const tsExports: Creation<TsExport>[] = exportSymbols.map((symbol) => {\n          const name = symbol.getName();\n          const typeSpecifier = getExportSymbolTypeRecursive(\n            symbol,\n            sourceFile,\n            debug\n          );\n\n          const exportObject: Creation<TsExport> = {\n            name,\n            slug: kebabCase(name),\n            operationRelativeTypescriptFilePath,\n            // TODO:\n            comments: [],\n            type: typeSpecifier?.type,\n            hasGeneric: typeSpecifier?.hasGeneric,\n          };\n          return exportObject;\n        });\n\n        return tsExports;\n      },\n      10\n    )\n  )\n    .filter(notEmpty)\n    .flat();\n\n  const allTsImports = (\n    await mapMany(\n      sourceFiles,\n      async (sourceFile) => {\n        const absoluteFilePath = sourceFile.getFilePath();\n        if (!absoluteFilePath) return;\n        const operationRelativeTypescriptFilePath = makeRelative(\n          absoluteFilePath,\n          operationBasePath\n        );\n\n        try {\n          const importDeclarations: ImportDeclaration[] =\n            sourceFile.getImportDeclarations();\n\n          const importInfos = importDeclarations\n            .map((importDeclaration) => {\n              try {\n                const module = String(\n                  importDeclaration.getModuleSpecifier().getLiteralText()\n                );\n                const namedImports: NamedImport[] = importDeclaration\n                  .getNamedImports()\n                  .map((x) => {\n                    const name = x.getName();\n\n                    const isOperation = allOperations.includes(module);\n\n                    const typeSpecifier = isOperation\n                      ? getTypeFromImportSpecifierRecursive(x, debug)\n                      : undefined;\n\n                    const namedImport: NamedImport = {\n                      name,\n                      slug: kebabCase(name),\n                      type: typeSpecifier?.type,\n                      hasGeneric: typeSpecifier?.hasGeneric,\n                    };\n\n                    return namedImport;\n                  });\n\n                const isModuleResolved =\n                  !!importDeclaration.getModuleSpecifierSourceFile();\n\n                return { namedImports, module, isModuleResolved };\n              } catch (e) {\n                console.log(\n                  `catched generating import-info for import-declaration`\n                );\n              }\n            })\n            .filter(notEmpty);\n\n          const tsImports: Creation<TsImport>[] = importInfos\n            .map((importInfo) => {\n              const { module, namedImports, isModuleResolved } = importInfo;\n\n              const nodeModules = [\"fs\", \"path\"];\n              const reactModules = [\n                \"react\",\n                \"react-dom\",\n                \"react-native\",\n                \"expo\",\n              ];\n\n              const classification: ImportClassification = nodeModules.includes(\n                module\n              )\n                ? \"node\"\n                : reactModules.includes(module)\n                ? \"react\"\n                : allOperations.includes(module)\n                ? \"operation\"\n                : !isAbsoluteImport(module)\n                ? \"internal\"\n                : \"package\";\n\n              const importObjects: Creation<TsImport>[] = namedImports.map(\n                (namedImport) => ({\n                  ...namedImport,\n                  module,\n                  isModuleResolved,\n                  // TODO\n                  comments: [],\n                  operationRelativeTypescriptFilePath,\n                  classification,\n                  isAbsolute: isAbsoluteImport(module),\n                  isModuleFromMonorepo: allOperations.includes(module),\n                  // NB: will not be resolved if build folder doesn't exist or if entry file doesn't exist\n                })\n              );\n\n              return importObjects;\n            })\n            .filter(notEmpty)\n            .flat();\n\n          return tsImports;\n        } catch (e) {\n          return;\n        }\n      },\n      10\n    )\n  )\n    .filter(notEmpty)\n    .flat();\n\n  return { imports: allTsImports, exports: allTsExports };\n}",
  "description": "Uses ts-morph to get all exports inside all files in a project or an array of source files.\nDoesn't use index, it actually looks in all files except index,\nso some of them may not be exported from the package itself depending on your indexing strategy!",
  "id": "ftdioibnlnlsqouzfgqkhnba"
}