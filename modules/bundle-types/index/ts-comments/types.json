[{"id":"DQxVUGdrsNBFMToF","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/bundle-types/src/types.ts","srcFileId":"/types","operationFolderName":"bundle-types","relativeFilePathFromSrc":"/types.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/bundle-types","operationName":"bundle-types","comment":"later we can make this an enum! it can be auto-generated along with enums for the operation paths, and more things alike.\n\nif it's an enum it will automatically be possible to select a value from it in the simplified schema form :D\n\nbesides simply having OperationName, we can have specific operation classification operation names:\n\n- JsOperationName (js)\n- NodeOperationName (node)\n- ServerOperationName (server)\n- AppShellOperationName (web, app, etc.)\n- UiOperationName (ui-es6 and ui-es5)","rawStatement":"export type OperationName = string;","parameters":{},"types":[],"firstLine":1,"lastLine":13},{"id":"DQxVUGdrsNBFMToF","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/bundle-types/src/types.ts","srcFileId":"/types","operationFolderName":"bundle-types","relativeFilePathFromSrc":"/types.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/bundle-types","operationName":"bundle-types","comment":"later this could be known by the frontend so it will render a ui to select a folder\n\nWe need to figure out how we can know all type types in between when getting the type definition schema, not only the final type. If I'm lucky there is a way to find it as a #ref in a consistent way.","rawStatement":"export type ProjectRelativeFolderPath = string;","parameters":{},"types":[],"firstLine":17,"lastLine":21},{"id":"DQxVUGdrsNBFMToF","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/bundle-types/src/types.ts","srcFileId":"/types","operationFolderName":"bundle-types","relativeFilePathFromSrc":"/types.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/bundle-types","operationName":"bundle-types","comment":"This type can specify a frontend and backend that belong to each other. it doesn't include all operations that the ui or server are dependent on, they are calculated separately","rawStatement":"export interface FrontBackBundle {\n  /**\n   * any operation names that are not necesarily dependencies of the named front-back bundle but still need to be available.\n   */\n  operations?: OperationPrivacy[];\n  /**\n   * (optional) main shared ui package of the frontend\n   */\n  uiOperationName?: string;\n  /**\n   * which app shell(s) or app operations are there for the frontend?\n   */\n  appShellOperationNames?: string[];\n\n  /** operation name for server, if this UI is connected to one */\n  serverOperationName?: string;\n\n  /**\n   * if there is a ui and it has a web-shell, and it is deployed somewhere into production, add the deployed domain here.\n   */\n  productionWebUrl?: string;\n  /**\n   * if the server is to be deployed, specify the server-env package that exposes the server environment variables (JSON) to the ui\n   *\n   * By default, uses \"server-env\" operation, which simply exposes a configuration env.json file. the generation of the bundle will set the \"remoteServer\" key in this env.json to the \"productionApiUrl\" so the deployed version can reach the api\n   */\n  envOperationName?: string;\n\n  /**\n   * if there is one, it should be specified here (without trailing slash)\n   */\n  productionApiUrl?: string;\n\n  /**\n   * if this is provided, all endpoints require this auth token to be provided, or the endpoints do not work\n   *\n   * if you wish to have a more extensive authentication method for your endpoints, make sure to create your own auth layer\n   */\n  endpointsAuthToken?: string;\n}","parameters":{},"types":[],"firstLine":43,"lastLine":45},{"id":"DQxVUGdrsNBFMToF","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/bundle-types/src/types.ts","srcFileId":"/types","operationFolderName":"bundle-types","relativeFilePathFromSrc":"/types.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/bundle-types","operationName":"bundle-types","comment":"configuration that can be applied when generating a new bundle","rawStatement":"export type GenerateBundleConfig = {\n  /** skips the step where it gets the new stuff from github */\n  skipPull?: boolean;\n  /** skips the step where it pushes the new bundle to remote */\n  skipPush?: boolean;\n  /** skips the step where it saves to the db */\n  skipUpsert?: boolean;\n  /** descriptioin for git commit, if pushing. Default is \"monorepo update\" */\n  description?: string;\n  /** normally, the informationStrategy is taken from BundleConfig (if present). Can be overwritten with this setting */\n  informationStrategy?: InformationStrategy;\n  debug?: boolean;\n  /**\n   * optionally, specify a custom branch name to pull from\n   */\n  branchName?: string;\n};","parameters":{},"types":[],"firstLine":87,"lastLine":89},{"id":"DQxVUGdrsNBFMToF","name":"Comment","slug":"comment","relativePathFromProjectRoot":"/tools/types/bundle-types/src/types.ts","srcFileId":"/types","operationFolderName":"bundle-types","relativeFilePathFromSrc":"/types.ts","relativeOperationBasePathFromProjectRoot":"/tools/types/bundle-types","operationName":"bundle-types","comment":"push (default): take needed information from project and push to bundle (removing the existing info)\n\npullReplace: pull bundle and keep its information intact, not taking anything new from the OS, replacing all the information we had from these models in the OS\n\npullMerge: pull bundle and use its information in conjunction with the information we had in the OS. This option will merge both information sources, removing duplicate IDs\n\nNB: Later we may want to define this setting on a per-model basis!","rawStatement":"export type InformationStrategy = \"push\" | \"pullReplace\" | \"pullMerge\";","parameters":{},"types":["nb"],"firstLine":108,"lastLine":116}]