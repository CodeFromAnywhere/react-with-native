[
  {
    "createdAt": 1666263103646,
    "updatedAt": 1666263103646,
    "deletedAt": 0,
    "createdFirstAt": 1666263103646,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/readTypescriptFile.ts",
    "comment": "Reads and parses a markdown file",
    "rawStatement": "export const readTypescriptFile = async (\n  filePath: Path\n): Promise<TypescriptIndex | null> => {\n  const operationBasePath = findOperationBasePath(filePath);\n  if (!operationBasePath) return null;\n  const operationName = getLastFolder(operationBasePath);\n\n  const operationRelativeTypescriptFilePath = getOperationRelativePath(\n    filePath,\n    operationBasePath\n  );\n\n  const getFileIndexes = <T extends keyof IndexModels>(\n    indexModelName: T\n  ): Promise<IndexModels[T][]> => {\n    const result = db\n      // TODO: make it more efficient by just finding the correct JSON files instead of all files in the operation.\n      .get(indexModelName, { operationName })\n      .then((result) =>\n        result.filter((x) => {\n          return (\n            x.operationRelativeTypescriptFilePath ===\n            operationRelativeTypescriptFilePath\n          );\n        })\n      );\n\n    return result;\n  };\n\n  // TODO: is this needed?\n  const pathParse = path.parse(filePath);\n  const isTypescriptFile = [\"ts\", \"tsx\"].includes(pathParse.ext.slice(1));\n  if (!isTypescriptFile) return null;\n  if (!fs.existsSync(filePath)) return null;\n\n  const typescriptIndex: TypescriptIndex = {\n    tsBuildErrors: await getFileIndexes(\"TsBuildError\"),\n    tsLintWarnings: await getFileIndexes(\"TsLintWarning\"),\n    tsFunctions: await getFileIndexes(\"TsFunction\"),\n    tsVariables: await getFileIndexes(\"TsVariable\"),\n    tsInterfaces: await getFileIndexes(\"TsInterface\"),\n    tsComments: await getFileIndexes(\"TsComment\"),\n    tsImports: await getFileIndexes(\"TsImport\"),\n    tsExports: await getFileIndexes(\"TsExport\"),\n  };\n\n  return typescriptIndex;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 21,
    "lastLine": 24,
    "id": "fpixyigezkehiqjagjadfbnh"
  },
  {
    "createdAt": 1666263103646,
    "updatedAt": 1666263103646,
    "deletedAt": 0,
    "createdFirstAt": 1666263103646,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/readTypescriptFile.ts",
    "comment": "get a Typescript index for all that is found in a folder",
    "rawStatement": "export const getFolderTypescriptIndex = async ({\n  basePath,\n  filter,\n  sort,\n  type,\n  filePath,\n}: {\n  /**\n   * if given, basePath is ignored\n   *\n   */\n  filePath?: string | string[];\n  /**\n   * is ignored if filePath is provided\n   *\n   * if this path is a single path anywhere in an operaiton, it will only take that operation\n   *\n   * otherwise, it will find all operation folders in that path\n   */\n  basePath?: string | string[];\n\n  /**\n   * if specified, only returns one specific type\n   *\n   * returns all types by default\n   */\n  type?: keyof IndexModels | null;\n\n  filter?: IndexFilter;\n\n  /**\n   * TODO: make functions be sortable:\n   * - alphabetic\n   * - input type\n   * - output type\n   * - usage amount\n   */\n  sort?: string;\n}): Promise<TypescriptIndex | null> => {\n  const operationBasePath =\n    basePath && !Array.isArray(basePath)\n      ? findOperationBasePath(basePath)\n      : undefined;\n\n  // console.log(\"MMMM\", { basePath, operationBasePath });\n\n  const groupedFiles: GroupedFiles = operationBasePath\n    ? { [operationBasePath]: [] }\n    : filePath && filePath.length > 0\n    ? makeArray(filePath).reduce((groups, filePath) => {\n        const operationBasePath = findOperationBasePath(filePath);\n        if (operationBasePath) {\n          groups[operationBasePath] = groups[operationBasePath]\n            ? groups[operationBasePath].concat(filePath)\n            : [filePath];\n        }\n        return groups;\n      }, {} as GroupedFiles)\n    : (await exploreOperationFolders({ basePath })).reduce(\n        (groups, operationBasePath) => {\n          groups[operationBasePath] = [];\n          return groups;\n        },\n        {} as GroupedFiles\n      );\n\n  const typescriptIndexes = await Promise.all(\n    Object.keys(groupedFiles).map(async (operationBasePath) => {\n      const files = groupedFiles[operationBasePath];\n\n      const tsBuildErrors =\n        type === \"TsBuildError\" || !type\n          ? await getOperationIndexModel(\n              \"TsBuildError\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsLintWarnings =\n        type === \"TsLintWarning\" || !type\n          ? await getOperationIndexModel(\n              \"TsLintWarning\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsFunctions =\n        type === \"TsFunction\" || !type\n          ? await getOperationIndexModel(\"TsFunction\", operationBasePath, files)\n          : [];\n\n      const extendedTsFuntions = await Promise.all(\n        tsFunctions.map(async (tsFunction) => ({\n          ...tsFunction,\n          dependantFiles: tsFunction.operationName\n            ? await findDependants({\n                operationName: tsFunction.operationName,\n                importName: tsFunction.name,\n              })\n            : [],\n        }))\n      );\n\n      const tsVariables =\n        type === \"TsVariable\" || !type\n          ? await getOperationIndexModel(\"TsVariable\", operationBasePath, files)\n          : [];\n\n      const tsInterfaces =\n        type === \"TsInterface\" || !type\n          ? await getOperationIndexModel(\n              \"TsInterface\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsComments =\n        type === \"TsComment\" || !type\n          ? await getOperationIndexModel(\"TsComment\", operationBasePath, files)\n          : [];\n\n      const tsImports =\n        type === \"TsImport\" || !type\n          ? await getOperationIndexModel(\"TsImport\", operationBasePath, files)\n          : [];\n\n      const tsExports =\n        type === \"TsExport\" || !type\n          ? await getOperationIndexModel(\"TsExport\", operationBasePath, files)\n          : [];\n\n      const filteredInterfaces = tsInterfaces.filter((x) =>\n        filter?.interfaceIsDbModel ? x.isDbModel : true\n      );\n\n      const typescriptIndex: TypescriptIndex = {\n        tsBuildErrors,\n        tsLintWarnings,\n        tsFunctions: extendedTsFuntions,\n        tsVariables,\n        tsInterfaces: filteredInterfaces,\n        tsComments: tsComments.filter((comment) =>\n          filter?.hasCommentTypes\n            ? comment.types.find((type) =>\n                filter.hasCommentTypes!.includes(type)\n              )\n            : true\n        ),\n        tsImports,\n        tsExports,\n      };\n\n      return typescriptIndex;\n    })\n  );\n\n  const mergedTypescriptIndex = typescriptIndexes.reduce((merged, current) => {\n    if (merged) {\n      const indexModels = Object.keys(merged) as (keyof TypescriptIndex)[];\n\n      const together = mergeObjectsArray(\n        indexModels.map((indexModelName) => {\n          const filterOnName =\n            indexModelName === \"tsComments\" ? () => true : uniqueNames;\n\n          return {\n            [indexModelName]: [\n              ...merged[indexModelName],\n              ...current[indexModelName],\n            ].filter(filterOnName),\n          };\n        })\n      ) as TypescriptIndex;\n\n      return together;\n    }\n\n    return current;\n  }, null as TypescriptIndex | null);\n\n  return mergedTypescriptIndex;\n};",
    "parameters": {},
    "types": [],
    "firstLine": 119,
    "lastLine": 121,
    "id": "vcmxxfyyswfanjifpgwzdopm"
  }
]