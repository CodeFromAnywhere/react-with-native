{
  "createdAt": 1666263103318,
  "updatedAt": 1666263103318,
  "deletedAt": 0,
  "createdFirstAt": 1666263103318,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "getFolderTypescriptIndex",
  "slug": "get-folder-typescript-index",
  "operationRelativeTypescriptFilePath": "src/readTypescriptFile.ts",
  "type": {
    "rawType": "({ basePath, filter, sort, type, filePath, }: { filePath?: string | string[] | undefined; basePath?: string | string[] | undefined; type?: keyof import(\"/Users/king/King/operations/tools/types/code-types/build/TypescriptIndex\").IndexModels | null | undefined; filter?: import(\"/Users/king/King/operations/tools/parsing/read-files/read-typescript-file/src/readTypescriptFile\").IndexFilter | undefined; sort?: string | undefined; }) => Promise<import(\"/Users/king/King/operations/tools/types/code-types/build/TypescriptIndex\").TypescriptIndex | null>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async ({\n  basePath,\n  filter,\n  sort,\n  type,\n  filePath,\n}: {\n  /**\n   * if given, basePath is ignored\n   *\n   */\n  filePath?: string | string[];\n  /**\n   * is ignored if filePath is provided\n   *\n   * if this path is a single path anywhere in an operaiton, it will only take that operation\n   *\n   * otherwise, it will find all operation folders in that path\n   */\n  basePath?: string | string[];\n\n  /**\n   * if specified, only returns one specific type\n   *\n   * returns all types by default\n   */\n  type?: keyof IndexModels | null;\n\n  filter?: IndexFilter;\n\n  /**\n   * TODO: make functions be sortable:\n   * - alphabetic\n   * - input type\n   * - output type\n   * - usage amount\n   */\n  sort?: string;\n}): Promise<TypescriptIndex | null> => {\n  const operationBasePath =\n    basePath && !Array.isArray(basePath)\n      ? findOperationBasePath(basePath)\n      : undefined;\n\n  // console.log(\"MMMM\", { basePath, operationBasePath });\n\n  const groupedFiles: GroupedFiles = operationBasePath\n    ? { [operationBasePath]: [] }\n    : filePath && filePath.length > 0\n    ? makeArray(filePath).reduce((groups, filePath) => {\n        const operationBasePath = findOperationBasePath(filePath);\n        if (operationBasePath) {\n          groups[operationBasePath] = groups[operationBasePath]\n            ? groups[operationBasePath].concat(filePath)\n            : [filePath];\n        }\n        return groups;\n      }, {} as GroupedFiles)\n    : (await exploreOperationFolders({ basePath })).reduce(\n        (groups, operationBasePath) => {\n          groups[operationBasePath] = [];\n          return groups;\n        },\n        {} as GroupedFiles\n      );\n\n  const typescriptIndexes = await Promise.all(\n    Object.keys(groupedFiles).map(async (operationBasePath) => {\n      const files = groupedFiles[operationBasePath];\n\n      const tsBuildErrors =\n        type === \"TsBuildError\" || !type\n          ? await getOperationIndexModel(\n              \"TsBuildError\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsLintWarnings =\n        type === \"TsLintWarning\" || !type\n          ? await getOperationIndexModel(\n              \"TsLintWarning\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsFunctions =\n        type === \"TsFunction\" || !type\n          ? await getOperationIndexModel(\"TsFunction\", operationBasePath, files)\n          : [];\n\n      const extendedTsFuntions = await Promise.all(\n        tsFunctions.map(async (tsFunction) => ({\n          ...tsFunction,\n          dependantFiles: tsFunction.operationName\n            ? await findDependants({\n                operationName: tsFunction.operationName,\n                importName: tsFunction.name,\n              })\n            : [],\n        }))\n      );\n\n      const tsVariables =\n        type === \"TsVariable\" || !type\n          ? await getOperationIndexModel(\"TsVariable\", operationBasePath, files)\n          : [];\n\n      const tsInterfaces =\n        type === \"TsInterface\" || !type\n          ? await getOperationIndexModel(\n              \"TsInterface\",\n              operationBasePath,\n              files\n            )\n          : [];\n\n      const tsComments =\n        type === \"TsComment\" || !type\n          ? await getOperationIndexModel(\"TsComment\", operationBasePath, files)\n          : [];\n\n      const tsImports =\n        type === \"TsImport\" || !type\n          ? await getOperationIndexModel(\"TsImport\", operationBasePath, files)\n          : [];\n\n      const tsExports =\n        type === \"TsExport\" || !type\n          ? await getOperationIndexModel(\"TsExport\", operationBasePath, files)\n          : [];\n\n      const filteredInterfaces = tsInterfaces.filter((x) =>\n        filter?.interfaceIsDbModel ? x.isDbModel : true\n      );\n\n      const typescriptIndex: TypescriptIndex = {\n        tsBuildErrors,\n        tsLintWarnings,\n        tsFunctions: extendedTsFuntions,\n        tsVariables,\n        tsInterfaces: filteredInterfaces,\n        tsComments: tsComments.filter((comment) =>\n          filter?.hasCommentTypes\n            ? comment.types.find((type) =>\n                filter.hasCommentTypes!.includes(type)\n              )\n            : true\n        ),\n        tsImports,\n        tsExports,\n      };\n\n      return typescriptIndex;\n    })\n  );\n\n  const mergedTypescriptIndex = typescriptIndexes.reduce((merged, current) => {\n    if (merged) {\n      const indexModels = Object.keys(merged) as (keyof TypescriptIndex)[];\n\n      const together = mergeObjectsArray(\n        indexModels.map((indexModelName) => {\n          const filterOnName =\n            indexModelName === \"tsComments\" ? () => true : uniqueNames;\n\n          return {\n            [indexModelName]: [\n              ...merged[indexModelName],\n              ...current[indexModelName],\n            ].filter(filterOnName),\n          };\n        })\n      ) as TypescriptIndex;\n\n      return together;\n    }\n\n    return current;\n  }, null as TypescriptIndex | null);\n\n  return mergedTypescriptIndex;\n}",
  "description": "get a Typescript index for all that is found in a folder",
  "id": "tgrvmlwziypdhcibwhdztqom"
}