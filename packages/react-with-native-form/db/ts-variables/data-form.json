{
  "createdAt": 1666261374616,
  "updatedAt": 1666261374616,
  "deletedAt": 0,
  "createdFirstAt": 1666261374616,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "DataForm",
  "slug": "data-form",
  "operationRelativeTypescriptFilePath": "src/general.tsx",
  "type": {
    "rawType": "<TInputs, TState extends { [key: string]: any; }>({ fields, defaultValues, initialValues, onSubmit, withSubmitProps, noSubmit, submitButtonText, submitButtonColor, title, backButton, plugins, renderSubmitComponent, renderInputContainer, stickySubmit, renderTitle, submitClassName, errorClassName, successClassName, }: import(\"/Users/king/King/operations/tools/interfaces/vui/react-with-native/react-with-native-form/src/general\").DataFormProps<TInputs, TState>) => JSX.Element",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "<TInputs, TState extends { [key: string]: any }>({\n  fields,\n  defaultValues,\n  initialValues,\n  onSubmit,\n  withSubmitProps,\n  noSubmit,\n  submitButtonText,\n  submitButtonColor,\n  title,\n  backButton,\n  plugins,\n  renderSubmitComponent,\n  renderInputContainer,\n  stickySubmit,\n  renderTitle,\n  submitClassName,\n  errorClassName,\n  successClassName,\n}: DataFormProps<TInputs, TState>) => {\n  //sometimes use defaultValues (deprecated)\n\n  initialValues = initialValues ? initialValues : defaultValues;\n  if (!plugins) {\n    throw new Error(\"No plugins given\");\n  }\n  //Generate unique id for the form\n  const [id] = useState(`Form${String(Math.round(Math.random() * 1000000))}`);\n\n  const [fieldsWithReferences, setFieldsWithReferences] = useState<\n    ExtendedField<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  // need to have because we want to see when it's changed\n  const [fieldsWithoutReferences, setFieldsWithoutReferences] = useState<\n    Field<TInputs, Keys<TInputs>>[]\n  >([]);\n\n  useEffect(() => {\n    const fieldsWithoutReferencesLocal = fields.map((f) => f());\n\n    if (\n      // fieldsWithoutReferences.length === 0 && //NB: why was this here? caused the fields not to refresh\n      !sameFieldArray<Field<TInputs, Keys<TInputs>>[], TInputs>(\n        fieldsWithoutReferencesLocal,\n        fieldsWithoutReferences\n      )\n    ) {\n      setFieldsWithReferences(\n        fieldsWithoutReferencesLocal.map((fieldWithoutReference) => {\n          return {\n            ...fieldWithoutReference,\n            reference: createRef<HTMLDivElement>(),\n          };\n        })\n      );\n      setFieldsWithoutReferences(fieldsWithoutReferencesLocal);\n    }\n  }, [fields]);\n\n  const initialValuesPartial: TState = fields.reduce((all, field) => {\n    const type = field().type!;\n    const plugin = getPlugin(type, plugins);\n    const defaultInital = plugin.component.defaultInitialValue;\n    const initial = field().initialValue;\n    const key = field().field;\n    const value =\n      initial !== undefined\n        ? initial\n        : defaultInital !== undefined\n        ? defaultInital\n        : undefined;\n\n    return {\n      ...all,\n      [key]: value,\n    };\n  }, {}) as TState;\n\n  const initialState = { ...initialValuesPartial, ...initialValues };\n\n  const [state, setState] = useState<TState>(initialState);\n\n  //used to check if the initialValues have changed\n  const [initialValuesState, setInitialValuesState] = useState<\n    TState | undefined\n  >();\n\n  useEffect(() => {\n    if (!initialValuesState || !deepEqual(initialState, initialValuesState)) {\n      // console.log(\"initialValues have changed\");\n      setState(initialState);\n      setInitialValuesState(initialState);\n    }\n  }, [initialState]);\n\n  const [loading, setLoading] = useState(false);\n\n  const [errors, setErrors] = useState<Error[]>([]);\n  const [success, setSuccess] = useState<string | undefined>();\n\n  const notReadyFields = fieldsWithReferences.filter(\n    (x) => !x.shouldHide?.(state) && x.hasError?.(state[x.field], state)\n  );\n\n  const setErrorsReject: RejectType = (stringOrErrorArray) => {\n    if (stringOrErrorArray) {\n      //if the rejection provides a string, just return an array with 1 element: that string, on the global property path\n      //however, if it's an error array, return that. But make sure that if the propertyPath doesn't exist, it's still rendered globally.\n      const newErrors: Error[] =\n        typeof stringOrErrorArray === \"string\"\n          ? [\n              {\n                propertyPath: GLOBAL_PROPERTY_PATH,\n                message: stringOrErrorArray,\n              },\n            ]\n          : stringOrErrorArray.map(({ propertyPath, message }) => ({\n              message,\n              propertyPath: fields\n                .map((f) => f().field)\n                .find(\n                  (x) => propertyPath === x || propertyPath.startsWith(`${x}.`)\n                )\n                ? propertyPath\n                : GLOBAL_PROPERTY_PATH,\n            }));\n\n      //this only happens when there are no frontend errors, so it's safe to replace errors\n      setErrors(newErrors);\n\n      //scroll to the first field that contains an error\n      const firstNotReadyField = fieldsWithReferences.filter(\n        (x) => newErrors.find(errorOnField(x.field)) !== undefined\n      )[0];\n\n      if (isWeb) {\n        const top =\n          (firstNotReadyField?.reference?.current?.getBoundingClientRect?.()\n            .top || 0) +\n          (window.scrollY || 0) -\n          100;\n\n        // console.log(\"setErrorsReject: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  };\n\n  const firstErrorRef = notReadyFields[0]?.reference?.current;\n\n  function onClickSubmit(state: TState) {\n    const frontendErrorArray = fields.reduce((all, field) => {\n      const shouldNotHide = !field().shouldHide?.(state);\n      const errorMessage = field().hasError?.(state[field().field], state);\n      const hasError = shouldNotHide && errorMessage;\n\n      const errors =\n        typeof hasError === \"string\"\n          ? [{ propertyPath: field().field, message: hasError }]\n          : Array.isArray(hasError)\n          ? hasError\n          : [];\n\n      return [...all, ...errors];\n    }, [] as Error[]);\n\n    setErrors(frontendErrorArray);\n    //\n    if (frontendErrorArray?.length === 0) {\n      //no errors\n\n      setLoading(true);\n      onSubmit(\n        state,\n        (successMessage) => {\n          setSuccess(successMessage);\n          setLoading(false);\n        },\n        (stringOrErrorArray) => {\n          setErrorsReject(stringOrErrorArray);\n          setLoading(false);\n        }\n      );\n    } else {\n      //scroll to the error\n      /// onError(\"Please fill in all fields correctly\");\n\n      if (isWeb) {\n        const top =\n          (firstErrorRef?.getBoundingClientRect().top || 0) +\n          window.scrollY -\n          100;\n        // console.log(\"onClickSubmit: scrolling to first error field\");\n\n        window.scrollTo?.({\n          top,\n          behavior: \"smooth\",\n        });\n      }\n    }\n  }\n\n  const available = !loading && notReadyFields.length === 0;\n\n  const submitProps: SubmitProps = {\n    loading,\n    available,\n    submitButtonText,\n    submitButtonColor,\n    //should be overwritten on state change\n    onSubmit: () => onClickSubmit(state),\n    state,\n  };\n\n  useEffect(() => {\n    //console.log({ withSubmitProps: submitProps });\n    withSubmitProps?.(submitProps);\n  }, [loading, available, submitButtonText, submitButtonColor, firstErrorRef]);\n\n  const Title = renderTitle || DefaultTitle;\n\n  const Submit = () =>\n    noSubmit ? null : renderSubmitComponent ? (\n      renderSubmitComponent(submitProps)\n    ) : (\n      <Button\n        disabled={loading}\n        className={`${\n          available\n            ? `${submitButtonColor ? submitButtonColor : \"bg-green-500\"}`\n            : \"bg-gray-300\"\n        }  flex justify-center flex-row w-full px-4 py-2 text-sm font-medium text-white border border-transparent rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500`}\n        onClick={() => onClickSubmit(state)}\n        //......Extra\n        style={{\n          backgroundColor: \"#4ade80\",\n          color: \"white\",\n          width: \"100%\",\n          marginTop: 5,\n          marginBottom: 5,\n          display: \"flex\",\n          justifyContent: \"center\",\n          borderRadius: 10,\n          alignItems: \"center\",\n          borderColor: \"white\",\n          padding: 8,\n        }}\n      >\n        {loading ? (\n          <Div className=\"mr-2\">\n            <ActivityIndicator />\n          </Div>\n        ) : null}\n        <Label style={{ color: \"white\", fontWeight: \"bold\" }}>\n          {submitButtonText || \"Save\"}\n        </Label>\n      </Button>\n    );\n  const globalError = errors?.find(\n    (x) => x.propertyPath === GLOBAL_PROPERTY_PATH\n  );\n  return (\n    <Form\n      className=\"w-full\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        onClickSubmit(state);\n      }}\n    >\n      <Div className=\"w-full\">\n        <Title title={title} backButton={backButton} />\n\n        {success ? <P className={successClassName}>{success}</P> : null}\n        {globalError ? (\n          <P className={errorClassName || \"text-red-600\"}>\n            {globalError.message}\n          </P>\n        ) : null}\n\n        {fieldsWithReferences.map((field, index) => {\n          // Take the first plugin if the plugin isn't defined.\n          const plugin = getPlugin(field.type, plugins);\n\n          if (!plugin) {\n            return (\n              <P>\n                Plugin not found ({field.field}, {field.type})\n              </P>\n            );\n          }\n\n          const next = fields[index + 1]?.();\n\n          const onChange = (state: TState) => (newValue: any) => {\n\n            const newState = { [field.field]: newValue };\n            const newFullState = { ...state, ...newState };\n            const fieldErrors = errors.filter(errorOnField(field.field));\n\n            //check if field still has error(s)\n            const newFieldErrors = field.hasError?.(newValue, newFullState);\n            const newFieldErrorsAmount =\n              typeof newFieldErrors === \"string\"\n                ? 1\n                : Array.isArray(newFieldErrors)\n                ? newFieldErrors.length\n                : 0;\n            if (\n              fieldErrors.length > 0 &&\n              newFieldErrorsAmount !== fieldErrors.length\n            ) {\n              const newErrors = errors.filter(\n                (error) => !errorOnField(field.field)(error)\n              );\n              const newFieldErrorsArray: Error[] =\n                typeof newFieldErrors === \"string\"\n                  ? [{ message: newFieldErrors, propertyPath: field.field }]\n                  : Array.isArray(newFieldErrors)\n                  ? newFieldErrors\n                  : [];\n\n              setErrors([...newErrors, ...newFieldErrorsArray]);\n            }\n\n            setState(newFullState);\n            //NB: make sure to add the new state to the submitprops\n            withSubmitProps?.({\n              ...submitProps,\n              state: newFullState,\n              onSubmit: () => onClickSubmit(newFullState),\n            });\n          };\n\n          const uniqueFieldId = `${id || \"\"}.${field.field}`;\n\n          const inputErrors = errors.filter(\n            (e) =>\n              e.propertyPath === field.field ||\n              e.propertyPath.startsWith(`${field.field}.`)\n          );\n\n          return field.shouldHide?.(state) ? null : (\n            <Input\n              fieldName={field.field}\n              renderInputContainer={renderInputContainer}\n              uniqueFieldId={uniqueFieldId}\n              config={plugin.config}\n              plugin={plugin.component}\n              extra={field.extra}\n              reference={field.reference}\n              next={next}\n              key={`field-${field.field}`}\n              type={field.type!}\n              title={\n                field.titleFromState ? field.titleFromState(state) : field.title\n              }\n              value={state[field.field]}\n              onChange={onChange(state)}\n              isLast={index === fields?.length - 1}\n              startSection={field.startSection}\n              sectionTitle={field.sectionTitle}\n              description={field.description}\n              errors={inputErrors}\n            />\n          );\n        })}\n      </Div>\n      {Submit ? (\n        <Div\n          className={`${stickySubmit ? \"sticky bottom-0\" : \"\"} ${\n            submitClassName || \"mb-2 py-2\"\n          }`}\n        >\n          <Submit />\n        </Div>\n      ) : null}\n    </Form>\n  );\n}",
  "description": "",
  "id": "zksrqlsssihiqtmfujgmscit"
}